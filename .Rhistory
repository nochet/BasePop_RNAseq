stringsAsFactors = FALSE)
str(basep_all)
basep_all[1:20,1:8]
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(pamr)
library(limma)
# read extracted table
basep_all <- read.csv("../processed/results/ballG_all_results/gene_associated_texpr.csv",
stringsAsFactors = FALSE)
phenDat <- read.csv("describe_samples.csv", stringsAsFactors = FALSE)
head(phenDat)
str(phenDat)
# Create a full model matrix
# at this point we have only var of interest, no adj. vars
# since treatment has multiple levels, treat it as factor
mod.bg = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=pheno)
# Null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# a) get number of latent factors
n.sv = num.sv(basep_all, mod.bg, method = "leek")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(bladderbatch)
data(bladderdata)
library(pamr)
library(limma)
# Chunk 2
# 1. Data should be feature-by-sample matrix
# 2. sva assumes presence of 2 variable types: bio-vars, 2) covariate vars
# 3. Needs 2 matrices:
# 1) full model - terms for adjustment variables and variables of interest;
# 2) null model - terms for all adjustment variables but not variables of interest
# i.e. analyze assoc. btn vars of interest and gene expr, adjusting for adjustment vars
# 1. create model matrices using model.matrix()
# variable of interest: cancer status
# data stored in ExpressionSet
# Obtain phenotype variables
pheno = pData(bladderEset)
# Obtain expression variables
edata = exprs(bladderEset)
# visualize data
edata[1:5,1:5]
# Create a full model matrix
# at this point we have only var of interest, no adj. vars
# since cancer status has multiple levels, treat it as factor
mod = model.matrix(~as.factor(cancer), data=pheno)
# Chunk 3
# Null model (i.e. only adj. vars)
# Since we are not adj. for any vars now, only an intercept is included
mod0 = model.matrix(~1, data=pheno)
# a) get number of latent factors
n.sv = num.sv(edata, mod, method = "leek")
n.sv
# b) estimage surrogate variables
svobj = sva(edata, mod, mod0, n.sv=n.sv)
# Note on sv object:
# The function returns a list with four components, sv, pprob.gam, pprob.b, n.sv. sv is a matrix whose columns correspond to the estimated surrogate variables. They can be used in downstream analyses as described below. pprob.gam is the posterior probability that each gene is associated with one or more latent variables [?]. pprob.b is the posterior probability that each gene is associated with the variables of interest [?]. n.sv is the number of surrogate variables estimated by the sva.
# Chunk 4
# f.pvalue() calculates parametric F-test p-values for EACH row of data matrix
# F-test compares mod and mod0
# They MUST be nested models (i.e. all variables in mod0 must appear in mod)
# 1) First, calculate F-test p-values for differential expression with respect to cancer status, without adjusting for surrogate variables, adjust them for multiple testing, and calculate the number that are significant with a Q-value less than 0.05.
pValues = f.pvalue(edata, mod, mod0)
qValues = p.adjust(pValues, method = "BH") # BH, Benjamini-Hochberg for FDR
# Note that nearly 70% of the genes are strongly di erentially expressed at an FDR of less than 5% between groups. This number seems artificially high, even for a strong phenotype like cancer
# 2) Adjust for surrogates
# a) include surrogates in both full and null models, then get p-vals and q-vals
modSv = cbind(mod, svobj$sv) # sv is matrix whose columns are estimated SVs
mod0Sv = cbind(mod0, svobj$sv)
pValuesSv = f.pvalue(edata, modSv, mod0Sv)
qValuesSv = p.adjust(pValuesSv, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# Chunk 5
# 1) fit a linear model with surrogate variables
fit = lmFit(edata, modSv)
#From here, you can use the limma functions to perform the usual analyses.
# Chunk 6
# 1) compute contrasts between pairs of cancer/normal terms
# no surrogates included here since SVs are only useful for adjustment
contrast.matrix <- cbind("C1"=c(-1,1,0,rep(0,svobj$n.sv)),
"C2"=c(0,-1,1,rep(0,svobj$n.sv)),
"C3"=c(-1,0,1,rep(0,svobj$n.sv)))
fitContrasts = contrasts.fit(fit,contrast.matrix)
# 2) calculate the test statistic using eBayes()
eb = eBayes(fitContrasts)
topTable(eb, adjust="BH")
# Chunk 7
# There must be a known batch variable in the data
batch = pheno$batch
# 1) Create a model matrix for adj. vars + bio-vars
# Note that you do not include batch in creating this model matrix - it will be included later in the ComBat function.
# In this case there are no other adj. vars so we simply fit an intercept term.
modcombat = model.matrix(~1, data=pheno) # i.e. mod0 above
# Chunk 8
# 2) Adjust for batch
combat_edata = ComBat(dat=edata, batch=batch, mod=modcombat, par.prior=TRUE, prior.plots=TRUE)
# An expression matrix with same dims as input, but adj. for batch is created.
# 3) Perform significance testing on the batch-corrected matrix using the model matrix and null model matrix as described before:
pValuesComBat = f.pvalue(combat_edata,mod,mod0)
qValuesComBat = p.adjust(pValuesComBat,method="BH")
# NOTE:
# par.prior=FALSE gives the nonparametric empirical Bayesian adj. (takes longer) # prior.plots=FALSE gives prior plots with black as kernel estimate of the empirical batch efect density and red as the parametric estimate.
plot(combat_edata)
# Chunk 9
combat_edata1 = ComBat(dat=edata, batch=batch, mod=modcombat, mean.only=TRUE, par.prior=TRUE, prior.plots=TRUE)
# Chunk 10
# add the ref.batch parameter - see tutorial (p.9) for rationale & application
str(edata)
# Obtain expression variables
edata = exprs(bladderEset)
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(bladderbatch)
data(bladderdata)
library(pamr)
library(limma)
# Chunk 2
# 1. Data should be feature-by-sample matrix
# 2. sva assumes presence of 2 variable types: bio-vars, 2) covariate vars
# 3. Needs 2 matrices:
# 1) full model - terms for adjustment variables and variables of interest;
# 2) null model - terms for all adjustment variables but not variables of interest
# i.e. analyze assoc. btn vars of interest and gene expr, adjusting for adjustment vars
# 1. create model matrices using model.matrix()
# variable of interest: cancer status
# data stored in ExpressionSet
# Obtain phenotype variables
pheno = pData(bladderEset)
# Obtain expression variables
edata = exprs(bladderEset)
# visualize data
edata[1:5,1:5]
# Create a full model matrix
# at this point we have only var of interest, no adj. vars
# since cancer status has multiple levels, treat it as factor
mod = model.matrix(~as.factor(cancer), data=pheno)
# Chunk 3
# Null model (i.e. only adj. vars)
# Since we are not adj. for any vars now, only an intercept is included
mod0 = model.matrix(~1, data=pheno)
# a) get number of latent factors
n.sv = num.sv(edata, mod, method = "leek")
n.sv
# b) estimage surrogate variables
svobj = sva(edata, mod, mod0, n.sv=n.sv)
# Note on sv object:
# The function returns a list with four components, sv, pprob.gam, pprob.b, n.sv. sv is a matrix whose columns correspond to the estimated surrogate variables. They can be used in downstream analyses as described below. pprob.gam is the posterior probability that each gene is associated with one or more latent variables [?]. pprob.b is the posterior probability that each gene is associated with the variables of interest [?]. n.sv is the number of surrogate variables estimated by the sva.
# Chunk 4
# f.pvalue() calculates parametric F-test p-values for EACH row of data matrix
# F-test compares mod and mod0
# They MUST be nested models (i.e. all variables in mod0 must appear in mod)
# 1) First, calculate F-test p-values for differential expression with respect to cancer status, without adjusting for surrogate variables, adjust them for multiple testing, and calculate the number that are significant with a Q-value less than 0.05.
pValues = f.pvalue(edata, mod, mod0)
qValues = p.adjust(pValues, method = "BH") # BH, Benjamini-Hochberg for FDR
# Note that nearly 70% of the genes are strongly di erentially expressed at an FDR of less than 5% between groups. This number seems artificially high, even for a strong phenotype like cancer
# 2) Adjust for surrogates
# a) include surrogates in both full and null models, then get p-vals and q-vals
modSv = cbind(mod, svobj$sv) # sv is matrix whose columns are estimated SVs
mod0Sv = cbind(mod0, svobj$sv)
pValuesSv = f.pvalue(edata, modSv, mod0Sv)
qValuesSv = p.adjust(pValuesSv, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# Chunk 5
# 1) fit a linear model with surrogate variables
fit = lmFit(edata, modSv)
#From here, you can use the limma functions to perform the usual analyses.
# Chunk 6
# 1) compute contrasts between pairs of cancer/normal terms
# no surrogates included here since SVs are only useful for adjustment
contrast.matrix <- cbind("C1"=c(-1,1,0,rep(0,svobj$n.sv)),
"C2"=c(0,-1,1,rep(0,svobj$n.sv)),
"C3"=c(-1,0,1,rep(0,svobj$n.sv)))
fitContrasts = contrasts.fit(fit,contrast.matrix)
# 2) calculate the test statistic using eBayes()
eb = eBayes(fitContrasts)
topTable(eb, adjust="BH")
# Chunk 7
# There must be a known batch variable in the data
batch = pheno$batch
# 1) Create a model matrix for adj. vars + bio-vars
# Note that you do not include batch in creating this model matrix - it will be included later in the ComBat function.
# In this case there are no other adj. vars so we simply fit an intercept term.
modcombat = model.matrix(~1, data=pheno) # i.e. mod0 above
# Chunk 8
# 2) Adjust for batch
combat_edata = ComBat(dat=edata, batch=batch, mod=modcombat, par.prior=TRUE, prior.plots=TRUE)
# An expression matrix with same dims as input, but adj. for batch is created.
# 3) Perform significance testing on the batch-corrected matrix using the model matrix and null model matrix as described before:
pValuesComBat = f.pvalue(combat_edata,mod,mod0)
qValuesComBat = p.adjust(pValuesComBat,method="BH")
# NOTE:
# par.prior=FALSE gives the nonparametric empirical Bayesian adj. (takes longer) # prior.plots=FALSE gives prior plots with black as kernel estimate of the empirical batch efect density and red as the parametric estimate.
plot(combat_edata)
# Chunk 9
combat_edata1 = ComBat(dat=edata, batch=batch, mod=modcombat, mean.only=TRUE, par.prior=TRUE, prior.plots=TRUE)
# Chunk 10
# add the ref.batch parameter - see tutorial (p.9) for rationale & application
head(pheno)
head(edata)
# read extracted table
basep_all <- read.csv("../processed/results/ballG_all_results/gene_associated_texpr.csv",
stringsAsFactors = FALSE)
setwd("~/MyGithub/BasePop_RNAseq/base_pop/scripts")
# read extracted table
basep_all <- read.csv("../processed/results/ballG_all_results/gene_associated_texpr.csv",
stringsAsFactors = FALSE)
load("../processed/results/ballG_all_results/bg_ballG_filt.Rda")
# Obtain phenotype variables
phen = pData(bg_ballG_filt)
head(phen)
phenDat <- read.csv("describe_samples.csv", stringsAsFactors = FALSE)
head(phenDat)
length(pheno)
pheno
phenDat
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
setwd("~/MyGithub/BasePop_RNAseq/base_pop/scripts")
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
bg_ballG_filt <- subset(bg_ballG, "rowVars(texpr(bg_ballG)) >1", genomesubset=TRUE)
# See counts
#bg_ballG_filt
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
setwd("~/MyGithub/BasePop_RNAseq/base_pop/scripts")
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
bg_ballG_filt <- subset(bg_ballG, "rowVars(texpr(bg_ballG)) >1", genomesubset=TRUE)
# See counts
#bg_ballG_filt
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(pamr)
library(limma)
library(dplyr)
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(pamr)
library(limma)
library(dplyr)
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
setwd("~/MyGithub/BasePop_RNAseq/base_pop/scripts")
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
bg_ballG_filt <- subset(bg_ballG, "rowVars(texpr(bg_ballG)) >1", genomesubset=TRUE)
# See counts
#bg_ballG_filt
# syntax: expr(ballgown_object_name, <EXPRESSION_MEASUREMENT>)
transcript_fpkm = texpr(bg_ballG_filt, meas = "FPKM")
transcript_fpkm <-log2(transcript_fpkm+1)
# colnames(transcript_fpkm)<-phenDat$id
#transcript_cov = texpr(bg, 'cov')
#whole_tx_table = texpr(bg_ballG_filt, 'all')
#exon_mcov = eexpr(bg, 'mcov')
#junction_rcount = iexpr(bg)
#whole_intron_table = iexpr(bg, 'all')
gene_expression = gexpr(bg_ballG_filt)
# Note: expr functions return matrices unless meas = 'all',
# in which case some additional feature metadata is returned and the result is a data.frame
transcript_fpkm <- data.frame(geneNames=ballgown::transcriptNames(bg_ballG_filt), geneIDs=ballgown::geneIDs(bg_ballG_filt), transcript_fpkm)
indicies.bg <- match(transcript_fpkm$geneIDs, texpr(bg_ballG_filt, "all")$gene_id)
gene_names_bg <- texpr(bg_ballG_filt, "all")$t_name[indicies.bg]
transcript_fpkm$tname <- gene_names_bg
write.csv(transcript_fpkm,
"../processed/results/ballG_all_results/gene_associated_texpr.csv", row.names=FALSE)
transcript_fpkm[,c(1:2,57)]
# read extracted table
basep_all <- read.csv("../processed/results/ballG_all_results/gene_associated_texpr.csv",
stringsAsFactors = FALSE)
phenDat <- read.csv("describe_samples.csv", stringsAsFactors = FALSE)
# 1. create model matrices using model.matrix()
# variable of interest: treatment
# data stored in bg_ballG_filt
# Phenotype variables
phenDat = phenDat
# Expression variables
basep_all = basep_all %>%
select(-geneNames, -geneIDs) %>%
select(tname, everything())
nams <- basep_all$tname
rownames(basep_all) = make.names(nams, unique=TRUE)
basep_all$tname <- NULL
basep_all <- as.matrix(basep_all)
# Create a full model matrix
# at this point we have only var of interest, no adj. vars
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# a) get number of latent factors
n.sv = num.sv(basep_all, mod, method = "leek")
n.sv
# b) estimage surrogate variables
svobj = sva(basep_all, mod, mod0, n.sv=n.sv) # 49 SVs plus error
# 1) First, calculate F-test p-values for DE wrt diet, without adjusting for SVs
pValues = f.pvalue(basep_all, mod, mod0)
qValues = p.adjust(pValues, method = "BH")
# a) include surrogates in both full and null models, then get p-vals and q-vals
modSv = cbind(mod, svobj$sv) # sv is matrix whose columns are estimated SVs
mod0Sv = cbind(mod0, svobj$sv)
pValuesSv = f.pvalue(basep_all, modSv, mod0Sv)
qValuesSv = p.adjust(pValuesSv, method = "BH")
# 1) fit a linear model with surrogate variables
fit = lmFit(basep_all, modSv)
# 1) fit a linear model with surrogate variables
fit = lmFit(basep_all, modSv)
#From here, you can use the limma functions to perform the usual analyses.
?lmFit
str(svobj)
# 1) compute contrasts between pairs of diet terms
# no surrogates included here since SVs are only useful for adjustment
contrast.matrix <- cbind("C1"=c(-1,1,0,rep(0,svobj$n.sv)),
"C2"=c(0,-1,1,rep(0,svobj$n.sv)),
"C3"=c(-1,0,1,rep(0,svobj$n.sv)))
fitContrasts = contrasts.fit(fit,contrast.matrix)
# 2) calculate the test statistic using eBayes()
eb = eBayes(fitContrasts)
topTable(eb, adjust="BH")
mod0
mod
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(pamr)
library(limma)
library(dplyr)
# Chunk 2
# read extracted table
basep_all <- read.csv("../processed/results/ballG_all_results/gene_associated_texpr.csv",
stringsAsFactors = FALSE)
phenDat <- read.csv("describe_samples.csv", stringsAsFactors = FALSE)
# Chunk 3
# 1. create model matrices using model.matrix()
# variable of interest: treatment
# data stored in bg_ballG_filt
# Phenotype variables
phenDat = phenDat
# Expression variables
basep_all = basep_all %>%
select(-geneNames, -geneIDs) %>%
select(tname, everything())
nams <- basep_all$tname
rownames(basep_all) = make.names(nams, unique=TRUE)
basep_all$tname <- NULL
basep_all <- as.matrix(basep_all)
# Create a full model matrix
# at this point we have only var of interest, no adj. vars
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Chunk 4
# Null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# a) get number of latent factors
n.sv = num.sv(basep_all, mod, method = "leek")
n.sv
# b) estimage surrogate variables
svobj = sva(basep_all, mod, mod0, n.sv=n.sv)
svobj = sva(basep_all, mod, mod0)
# errors, see:
# https://www.biostars.org/p/198820/
# What does this error mean? - issue implementing SVA
# https://stackoverflow.com/questions/43101585/error-when-generating-the-sva-object-using-package-sva-in-r
# Chunk 5
# 1) First, calculate F-test p-values for DE wrt diet, without adjusting for SVs
pValues = f.pvalue(basep_all, mod, mod0)
qValues = p.adjust(pValues, method = "BH")
# 2) Adjust for surrogates
# a) include surrogates in both full and null models, then get p-vals and q-vals
modSv = cbind(mod, svobj$sv) # sv is matrix whose columns are estimated SVs
mod0Sv = cbind(mod0, svobj$sv)
pValuesSv = f.pvalue(basep_all, modSv, mod0Sv)
qValuesSv = p.adjust(pValuesSv, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# Chunk 6
# 1) fit a linear model with surrogate variables
fit = lmFit(basep_all, modSv)
#From here, you can use the limma functions to perform the usual analyses.
# Chunk 7
# 1) compute contrasts between pairs of diet terms
# no surrogates included here since SVs are only useful for adjustment
contrast.matrix <- cbind("C1"=c(-1,1,0,rep(0,svobj$n.sv)),
"C2"=c(0,-1,1,rep(0,svobj$n.sv)),
"C3"=c(-1,0,1,rep(0,svobj$n.sv)))
fitContrasts = contrasts.fit(fit,contrast.matrix)
# 2) calculate the test statistic using eBayes()
eb = eBayes(fitContrasts)
topTable(eb, adjust="BH")
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
library(sva)
library(pamr)
library(limma)
library(dplyr)
# Chunk 2
# read extracted table
basep_all <- read.csv("../processed/results/ballG_all_results/gene_associated_texpr.csv",
stringsAsFactors = FALSE)
phenDat <- read.csv("describe_samples.csv", stringsAsFactors = FALSE)
# Chunk 3
# 1. create model matrices using model.matrix()
# variable of interest: treatment
# data stored in bg_ballG_filt
# Phenotype variables
phenDat = phenDat
# Expression variables
basep_all = basep_all %>%
select(-geneNames, -geneIDs) %>%
select(tname, everything())
nams <- basep_all$tname
rownames(basep_all) = make.names(nams, unique=TRUE)
basep_all$tname <- NULL
basep_all <- as.matrix(basep_all)
# Create a full model matrix
# at this point we have only var of interest, no adj. vars
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Chunk 4
# Null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# a) get number of latent factors
n.sv = num.sv(basep_all, mod, method = "leek")
n.sv
# b) estimage surrogate variables
svobj = sva(basep_all, mod, mod0, n.sv=n.sv)
svobj = sva(basep_all, mod, mod0)
# errors, see:
# https://www.biostars.org/p/198820/
# What does this error mean? - issue implementing SVA
# https://stackoverflow.com/questions/43101585/error-when-generating-the-sva-object-using-package-sva-in-r
# Chunk 5
# 1) First, calculate F-test p-values for DE wrt diet, without adjusting for SVs
pValues = f.pvalue(basep_all, mod, mod0)
qValues = p.adjust(pValues, method = "BH")
# 2) Adjust for surrogates
# a) include surrogates in both full and null models, then get p-vals and q-vals
modSv = cbind(mod, svobj$sv) # sv is matrix whose columns are estimated SVs
mod0Sv = cbind(mod0, svobj$sv)
pValuesSv = f.pvalue(basep_all, modSv, mod0Sv)
qValuesSv = p.adjust(pValuesSv, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# Chunk 6
# 1) fit a linear model with surrogate variables
fit = lmFit(basep_all, modSv)
#From here, you can use the limma functions to perform the usual analyses.
# Chunk 7
# 1) compute contrasts between pairs of diet terms
# no surrogates included here since SVs are only useful for adjustment
contrast.matrix <- cbind("C1"=c(-1,1,0,rep(0,svobj$n.sv)),
"C2"=c(0,-1,1,rep(0,svobj$n.sv)),
"C3"=c(-1,0,1,rep(0,svobj$n.sv)))
fitContrasts = contrasts.fit(fit,contrast.matrix)
# 2) calculate the test statistic using eBayes()
eb = eBayes(fitContrasts)
topTable(eb, adjust="BH")
?n.sv
?n.sv
?n.sv
??n.sv
?sva
?num.sv
n.sv = num.sv(basep_all, mod, method = "be")
n.sv
# a) get number of latent factors
n.sv = num.sv(basep_all, mod, method = "leek")
n.sv
n.sv = num.sv(basep_all, mod, method = "be")
n.sv
