# Only expression variables needed in matrix form - untransformed for svaseq
#nolog_gfpkm_svaseq = nolog_gfpkm_all %>%
#select(-GeneName)
nolog_gfpkm_svaseq <- as.matrix(nolog_gfpkm_svaseq)
n.sv_svaseq = num.sv(nolog_gfpkm_svaseq, mod, method = "be", B = 5) # B are iterations
n.sv_svaseq
# models
svaseqobj <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv=n.sv_svaseq, controls = NULL,
method = c("irw", "two-step","supervised"),  B = 5,
) # compare with vfilter inluded
svaseqobj$sv
plot(svaseqobj$sv, pch=19,col="red")
# NOTE on sva output:
# pprob.gam: A vector of the posterior probabilities each gene is affected by heterogeneity
# pprob.b: A vector of the posterior probabilities each gene is affected by mod n.sv
str(nolog_gfpkm_svaseq)
nolog_gfpkm_svaseq2 <- removeBatchEffect(nolog_gfpkm_svaseq, covariates = Covar)
# 1. sva
# Create a full model matrix without adjustment variables
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Create null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# Get number of batch variables
#n.sv = num.sv(basep_all, mod, method = "leek")
n.sv = num.sv(log_gfpkm_sva, mod, method = "be", B = 5) # B are iterations
n.sv
# Note: B should be used only when method = "be"
# b) Estimage surrogate variables
svobj = sva(log_gfpkm_sva, mod, mod0, n.sv=n.sv, B = 5)
#svobj$sv
# use untransformed data - svaseq takes care
nolog_gfpkm_svaseq <- read.csv("../processed/results/ballG_all_results/nolog_gfpkm_all.csv",
stringsAsFactors = FALSE)
# Only expression variables needed in matrix form - untransformed for svaseq
#nolog_gfpkm_svaseq = nolog_gfpkm_all %>%
#select(-GeneName)
nolog_gfpkm_svaseq <- as.matrix(nolog_gfpkm_svaseq)
n.sv_svaseq = num.sv(nolog_gfpkm_svaseq, mod, method = "be", B = 5) # B are iterations
n.sv_svaseq
# models
svaseqobj <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv=n.sv_svaseq, controls = NULL,
method = c("irw", "two-step","supervised"),  B = 5,
) # compare with vfilter inluded
svaseqobj$sv
plot(svaseqobj$sv, pch=19,col="red")
# NOTE on sva output:
# pprob.gam: A vector of the posterior probabilities each gene is affected by heterogeneity
# pprob.b: A vector of the posterior probabilities each gene is affected by mod n.sv
str(nolog_gfpkm_svaseq)
nolog_gfpkm_svaseq2 <- removeBatchEffect(nolog_gfpkm_svaseq, covariates = Covar)
# 1) Calculate F-test p-values for DE wrt diet, without adjusting for SVs
pValues_svaseq = f.pvalue(nolog_gfpkm_svaseq, mod, mod0) #note mod used, not mod1
qValues_svaseq = p.adjust(pValues_svaseq, method = "BH")
# 2) Adjust for surrogates
# include surrogates in both full and null models, then get p-vals and q-vals
modSv_svaseq = cbind(mod, svaseqobj$sv)
# sv is matrix whose columns are estimated SVs
mod0Sv_svaseq = cbind(mod0, svaseqobj$sv)
pValuesSv_svaseq = f.pvalue(nolog_gfpkm_svaseq, modSv_svaseq, mod0Sv_svaseq)
qValuesSv_svaseq = p.adjust(pValuesSv_svaseq, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# BUT, how to get adjusted expression values for downstream analysis?
# a) can use function
svaseq.dat <- cleaningY(nolog_gfpkm_svaseq, mod = mod, svaobj = svaseqobj)
# compare plots
plot(nolog_gfpkm_svaseq[,c("C.1_H","C.2_H")])  # before sva
plot(svaseq.dat[,c("C.1_H","C.2_H")]) # after sva
# b) can use sva & limma
nolog_gfpkm_svaseq <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv_svaseq)
Covar <- as.factor(cbind(nolog_gfpkm_svaseq$sv))
nolog_gfpkm_svaseq2 <- removeBatchEffect(nolog_gfpkm_svaseq, covariates = Covar)
plot(nolog_gfpkm_svaseq2)
# a) can use function
svaseq.dat <- cleaningY(nolog_gfpkm_svaseq, mod = modSv_svaseq, svaobj = svaseqobj)
# use untransformed data - svaseq takes care
nolog_gfpkm_svaseq <- read.csv("../processed/results/ballG_all_results/nolog_gfpkm_all.csv",
stringsAsFactors = FALSE)
# Only expression variables needed in matrix form - untransformed for svaseq
#nolog_gfpkm_svaseq = nolog_gfpkm_all %>%
#select(-GeneName)
nolog_gfpkm_svaseq <- as.matrix(nolog_gfpkm_svaseq)
n.sv_svaseq = num.sv(nolog_gfpkm_svaseq, mod, method = "be", B = 5) # B are iterations
n.sv_svaseq
# models
svaseqobj <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv=n.sv_svaseq, controls = NULL,
method = c("irw", "two-step","supervised"),  B = 5,
) # compare with vfilter inluded
svaseqobj$sv
plot(svaseqobj$sv, pch=19,col="red")
# NOTE on sva output:
# pprob.gam: A vector of the posterior probabilities each gene is affected by heterogeneity
# pprob.b: A vector of the posterior probabilities each gene is affected by mod n.sv
# 1) Calculate F-test p-values for DE wrt diet, without adjusting for SVs
pValues_svaseq = f.pvalue(nolog_gfpkm_svaseq, mod, mod0) #note mod used, not mod1
qValues_svaseq = p.adjust(pValues_svaseq, method = "BH")
# 2) Adjust for surrogates
# include surrogates in both full and null models, then get p-vals and q-vals
modSv_svaseq = cbind(mod, svaseqobj$sv)
# sv is matrix whose columns are estimated SVs
mod0Sv_svaseq = cbind(mod0, svaseqobj$sv)
pValuesSv_svaseq = f.pvalue(nolog_gfpkm_svaseq, modSv_svaseq, mod0Sv_svaseq)
qValuesSv_svaseq = p.adjust(pValuesSv_svaseq, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# BUT, how to get adjusted expression values for downstream analysis?
# a) can use function
svaseq.dat <- cleaningY(nolog_gfpkm_svaseq, mod = modSv_svaseq, svaobj = svaseqobj)
# a) can use function
svaseq.dat <- cleaningY(nolog_gfpkm_svaseq, mod = mod, svaobj = svaseqobj)
# compare plots
plot(nolog_gfpkm_svaseq[,c("C.1_H","C.2_H")])  # before sva
plot(svaseq.dat[,c("C.1_H","C.2_H")]) # after sva
# b) can use sva & limma
nolog_gfpkm_svaseq <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv_svaseq)
Covar <- as.factor(cbind(nolog_gfpkm_svaseq$sv))
nolog_gfpkm_svaseq2 <- removeBatchEffect(nolog_gfpkm_svaseq, covariates = Covar)
plot(nolog_gfpkm_svaseq2)
#tfpkm_bg <-log2(svaseq.dat+1)
colnames(svaseq.dat) <- phenDat$id
head(svaseq.dat)
tbg$treatment <- rep(c("C","DR","HS"), each=18*nrow(svaseq.dat))
str(svaseq.dat)
phenDat
svaseq.dat[1:2,1:5]
# use untransformed data - svaseq takes care
nolog_gfpkm_svaseq <- read.csv("../processed/results/ballG_all_results/nolog_gfpkm_all.csv",
stringsAsFactors = FALSE)
# Only expression variables needed in matrix form - untransformed for svaseq
#nolog_gfpkm_svaseq = nolog_gfpkm_all %>%
#select(-GeneName)
nolog_gfpkm_svaseq <- as.matrix(nolog_gfpkm_svaseq)
n.sv_svaseq = num.sv(nolog_gfpkm_svaseq, mod, method = "be", B = 5) # B are iterations
n.sv_svaseq
# models
svaseqobj <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv=n.sv_svaseq, controls = NULL,
method = c("irw", "two-step","supervised"),  B = 5,
) # compare with vfilter inluded
svaseqobj$sv
plot(svaseqobj$sv, pch=19,col="red")
# NOTE on sva output:
# pprob.gam: A vector of the posterior probabilities each gene is affected by heterogeneity
# pprob.b: A vector of the posterior probabilities each gene is affected by mod n.sv
head(nolog_gfpkm_svaseq)
str(nolog_gfpkm_svaseq)
rownames(nolog_gfpkm_svaseq)
# use untransformed data - svaseq takes care
nolog_gfpkm_svaseq <- read.csv("../processed/results/ballG_all_results/nolog_gfpkm_all.csv",
stringsAsFactors = FALSE)
knitr::opts_chunk$set(echo = TRUE)
library(ballgown)
library(genefilter)
library(RSkittleBrewer)
library(tidyverse)
library(genefilter)
library(devtools)
#library(calibrate)
# phenotype data
phenDat <- read.csv("../processed/describe_samples_batch.csv", stringsAsFactors = FALSE)
#bg_ballG <- ballgown(dataDir = "../processed/ballG_all", samplePattern = "", pData = phenDat)
# Save all transcripts across tissues and diets as .Rda
#save(bg_ballG, file = "../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
load("../processed/results/ballG_all_results/bg_ballG_all_results.Rda")
# Dispplay a decsription
bg_ballG
bg_ballG_filt <- subset(bg_ballG, "rowVars(texpr(bg_ballG)) >1", genomesubset=TRUE)
save(bg_ballG_filt, file = "../processed/results/ballG_all_results/bg_ballG_filt.Rda")
## Qu.1 Both sva and RUVseq tutorials filter out non-expressed genes by requiring >5 reads in at least 2 samples for each gene
# i.e. `filter <- apply(zfGenes, 1, function(x) lengthx[x>5]) >2`
load("../processed/results/ballG_all_results/bg_ballG_filt.Rda")
gfpkm_all = gexpr(bg_ballG_filt)
str(gfpkm_all)
#get gene names
Gindicies <- match(rownames(gfpkm_all), texpr(bg_ballG_filt, 'all')$gene_id)
Gnames <- texpr(bg_ballG_filt, "all")$t_name[Gindicies]
rownames(gfpkm_all) <- Gnames
str(gfpkm_all)
head(gfpkm_all)
# log2 transform expr values, rename columns for sva
log_gfpkm_all <- log2(gfpkm_all+1)
head(log_gfpkm_all)
colnames(log_gfpkm_all) <- phenDat$id
head(log_gfpkm_all)
# Write results to csv
write.csv(log_gfpkm_all,
"../processed/results/ballG_all_results/log_gfpkm_all.csv",
row.names=FALSE)
gfpkm_all
# For svaseq - untransformed
colnames(gfpkm_all) <- phenDat$id
gfpkm_all
write.csv(gfpkm_all,
"../processed/results/ballG_all_results/nolog_gfpkm_all.csv",
row.names=TRUE)
head(gfpkm_all)
# Write results to csv
write.csv(log_gfpkm_all,
"../processed/results/ballG_all_results/log_gfpkm_all.csv",
row.names=TRUE)
log_gfpkm_all
# read table prepped from the ballgown `bg_ballG_all_results.Rda` object
log_gfpkm_sva <- read.csv("../processed/results/ballG_all_results/log_gfpkm_all.csv",
stringsAsFactors = FALSE)
# sample data
phenDat <- read.csv("../processed/describe_samples_batch.csv", stringsAsFactors = FALSE)
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(log_gfpkm_sva)
head(log_gfpkm_sva)
# 1. sva
# Create a full model matrix without adjustment variables
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Create null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# Get number of batch variables
#n.sv = num.sv(basep_all, mod, method = "leek")
n.sv = num.sv(log_gfpkm_sva, mod, method = "be", B = 5) # B are iterations
n.sv
# Note: B should be used only when method = "be"
# b) Estimage surrogate variables
svobj = sva(log_gfpkm_sva, mod, mod0, n.sv=n.sv, B = 5)
#svobj$sv
class(log_gfpkm_sva)
str(log_gfpkm_sva)
head(log_gfpkm_sva)
log_gfpkm_sva <- read.csv("../processed/results/ballG_all_results/log_gfpkm_all.csv",
stringsAsFactors = FALSE)
# sample data
phenDat <- read.csv("../processed/describe_samples_batch.csv", stringsAsFactors = FALSE)
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva))
head(log_gfpkm_sva)
type_convert(log_gfpkm_sva)
class(log_gfpkm_sva)
str(log_gfpkm_sva)
head(log_gfpkm_sva)
log_gfpkm_sva[1:4,1:5]
# 1. sva
# Create a full model matrix without adjustment variables
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Create null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# Get number of batch variables
#n.sv = num.sv(basep_all, mod, method = "leek")
n.sv = num.sv(log_gfpkm_sva, mod, method = "be", B = 5) # B are iterations
n.sv
# Note: B should be used only when method = "be"
# b) Estimage surrogate variables
svobj = sva(log_gfpkm_sva, mod, mod0, n.sv=n.sv, B = 5)
#svobj$sv
log_gfpkm_sva <- read.csv("../processed/results/ballG_all_results/log_gfpkm_all.csv",
stringsAsFactors = FALSE, row.names = TRUE)
library(readr)
dataset <- read_csv(NULL)
View(dataset)
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames =TRUE)
log_gfpkm_sva
log_gfpkm_sva[1:4,1:5]
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames =FALSE)
log_gfpkm_sva[1:4,1:5]
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames = X)
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames = log_gfpkm_sva$X)
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames = log_gfpkm_sva[,X)
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames = log_gfpkm_sva[,X])
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva), rownames = log_gfpkm_sva[,1])
# Prepare up data for sva
# Only expression variables needed in matrix form - log2-transformed for sva
#log_gfpkm_sva = log_gfpkm_all %>%
#select(-GeneName)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva))
rownames(log_gfpkm_sva) <- log_gfpkm_sva[,1]
log_gfpkm_sva[,1] <- NULL
log_gfpkm_sva
str(log_gfpkm_sva)
log_gfpkm_sva <- read.csv("../processed/results/ballG_all_results/log_gfpkm_all.csv",
stringsAsFactors = FALSE)
rownames(log_gfpkm_sva) <- log_gfpkm_sva[,1]
str(log_gfpkm_sva)
head(log_gfpkm_sva)
log_gfpkm_sva[,1] <- NULL
head(log_gfpkm_sva)
str(log_gfpkm_sva)
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva))
str(log_gfpkm_sva)
log_gfpkm_sva <- read.csv("../processed/results/ballG_all_results/log_gfpkm_all.csv",
stringsAsFactors = FALSE)
rownames(log_gfpkm_sva) <- log_gfpkm_sva[,1]
log_gfpkm_sva[,1] <- NULL
log_gfpkm_sva <- as.matrix(as.data.frame(log_gfpkm_sva))
# 1. sva
# Create a full model matrix without adjustment variables
# since treatment has multiple levels, treat it as factor
mod = model.matrix(~as.factor(treatment) + as.factor(tissue), data=phenDat)
# Create null model (i.e. only adj. vars)
# with no adjustment - just the intercept included
mod0 = model.matrix(~1, data=phenDat)
# Get number of batch variables
#n.sv = num.sv(basep_all, mod, method = "leek")
n.sv = num.sv(log_gfpkm_sva, mod, method = "be", B = 5) # B are iterations
n.sv
# Note: B should be used only when method = "be"
# b) Estimage surrogate variables
svobj = sva(log_gfpkm_sva, mod, mod0, n.sv=n.sv, B = 5)
#svobj$sv
mod.sva_adj <- model.matrix(~as.factor(treatment) +
as.factor(tissue) +
as.factor(group),
data=phenDat)
n.sv_adj = num.sv(log_gfpkm_sva, mod.sva_adj, method = "be", B = 5) # B are iterations
#n.sv_adj
svobj.adj = sva(log_gfpkm_sva, mod.sva_adj, mod0, n.sv=n.sv, B = 5)
#svobj.adj$sv
svobj
svobj$sv
# use untransformed data - svaseq takes care
nolog_gfpkm_svaseq <- read.csv("../processed/results/ballG_all_results/nolog_gfpkm_all.csv",
stringsAsFactors = FALSE)
rownames(nolog_gfpkm_svaseq) <- nolog_gfpkm_svaseq[,1]
nolog_gfpkm_svaseq[,1] <- NULL
# Only expression variables needed in matrix form - untransformed for svaseq
#nolog_gfpkm_svaseq = nolog_gfpkm_all %>%
#select(-GeneName)
nolog_gfpkm_svaseq <- as.matrix(nolog_gfpkm_svaseq)
n.sv_svaseq = num.sv(nolog_gfpkm_svaseq, mod, method = "be", B = 5) # B are iterations
n.sv_svaseq
# models
svaseqobj <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv=n.sv_svaseq, controls = NULL,
method = c("irw", "two-step","supervised"),  B = 5,
) # compare with vfilter inluded
svaseqobj$sv
plot(svaseqobj$sv, pch=19,col="red")
# 1) Calculate F-test p-values for DE wrt diet, without adjusting for SVs
pValues_svaseq = f.pvalue(nolog_gfpkm_svaseq, mod, mod0) #note mod used, not mod1
qValues_svaseq = p.adjust(pValues_svaseq, method = "BH")
# 2) Adjust for surrogates
# include surrogates in both full and null models, then get p-vals and q-vals
modSv_svaseq = cbind(mod, svaseqobj$sv)
# sv is matrix whose columns are estimated SVs
mod0Sv_svaseq = cbind(mod0, svaseqobj$sv)
pValuesSv_svaseq = f.pvalue(nolog_gfpkm_svaseq, modSv_svaseq, mod0Sv_svaseq)
qValuesSv_svaseq = p.adjust(pValuesSv_svaseq, method = "BH")
# These are the adjusted P-values and Q-values accounting for surrogate variables.
# BUT, how to get adjusted expression values for downstream analysis?
# a) can use function
svaseq.dat <- cleaningY(nolog_gfpkm_svaseq, mod = mod, svaobj = svaseqobj)
# compare plots
plot(nolog_gfpkm_svaseq[,c("C.1_H","C.2_H")])  # before sva
plot(svaseq.dat[,c("C.1_H","C.2_H")]) # after sva
# b) can use sva & limma
#nolog_gfpkm_svaseq <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv_svaseq)
#Covar <- as.factor(cbind(nolog_gfpkm_svaseq$sv))
#nolog_gfpkm_svaseq2 <- removeBatchEffect(nolog_gfpkm_svaseq, covariates = Covar)
#plot(nolog_gfpkm_svaseq2)
# Function to extract batch-corrected expression values from a sva object
# Ref:
# https://support.bioconductor.org/p/87508/
# https://support.bioconductor.org/p/47350/
cleaningY = function(y, mod, svaobj) {
X = cbind(mod, svaobj$sv)
Hat = solve(t(X)%*%X)%*%t(X)
beta = (Hat%*%t(y))
P = ncol(mod)
cleany = y-t(as.matrix(X[,-c(1:P)])%*%beta[-c(1:P),])
return(cleany)
}
# a) can use function
svaseq.dat <- cleaningY(nolog_gfpkm_svaseq, mod = mod, svaobj = svaseqobj)
# compare plots
plot(nolog_gfpkm_svaseq[,c("C.1_H","C.2_H")])  # before sva
plot(svaseq.dat[,c("C.1_H","C.2_H")]) # after sva
# b) can use sva & limma
#nolog_gfpkm_svaseq <- svaseq(nolog_gfpkm_svaseq, mod, mod0 , n.sv_svaseq)
#Covar <- as.factor(cbind(nolog_gfpkm_svaseq$sv))
#nolog_gfpkm_svaseq2 <- removeBatchEffect(nolog_gfpkm_svaseq, covariates = Covar)
#plot(nolog_gfpkm_svaseq2)
#tfpkm_bg <-log2(svaseq.dat+1)
colnames(svaseq.dat) <- phenDat$id
head(svaseq.dat)
tbg<- as.data.frame(svaseq.dat) %>% gather(id, fpkm)
tbg$treatment <- rep(c("C","DR","HS"), each=18*nrow(svaseq.dat))
tbg$tissue <- rep(c("B","H","O"),each=nrow(tfpkm_bg),6)
tbg$tissue <- rep(c("B","H","O"),each=nrow(svaseq.dat),6)
tbg$replicate <- rep(c(1,2,3,4,5,6),each=nrow(svaseq.dat)*3)
tbg$prep <- paste(tbg$treatment,tbg$replicate,sep="_")
tbg$trep <- paste(tbg$tissue,tbg$replicate,sep="_")
head(tbg)
b1 <- ggplot(tbg, aes(x=as.factor(prep), y=fpkm,color=treatment)) +
geom_boxplot(alpha=0.9) +
theme(axis.title.y = element_text(size = 24),
axis.title.x=element_blank(),
axis.text.x  = element_text(angle=90, vjust=0.5),
text = element_text(size = 20))+
scale_color_manual(values=c("#CC6666", "#9999CC", "#66CC99")) +
ylab(expression("log"[2]*"(FPKM + 1)")) +
xlab("Samples")+
facet_grid(tissue~.)
b1 + theme(legend.position="none")
b2 <- ggplot(tbg, aes(x=as.factor(trep), y=fpkm,color=tissue)) +
geom_boxplot(alpha=0.9) +
theme(axis.title.y = element_text(size = 24),
axis.title.x=element_blank(),
axis.text.x  = element_text(angle=90, vjust=0.5),
text = element_text(size = 20)) +
scale_color_manual(values=c("#CC6666", "#9999CC", "#66CC99")) +
ylab(expression("log"[2]*"(FPKM + 1)")) +
xlab("Tissue") +
#scale_fill_discrete(name="Samples")+
facet_grid(treatment~.)
b2 + theme(legend.position="none")
head(svaseq.dat)
# all samples
#gfpkm_bg <-gexpr(bg_ballG_filt)
#gfpkm_bg <-log2(gfpkm_bg +1)
#colnames(gfpkm_bg)<-phenDat$id
save(svaseq.dat, file = "../processed/results/ballG_all_results/svaseq_dat.Rda")
X<- t(scale(t(tbg),center=TRUE,scale=FALSE))
sv<- svd(t(X))
tbg
str(tbg)
?prcomp
prcomp(tbg)
prcomp(tbg$fpkm)
plot(prcomp(tbg$fpkm))
plot(prcomp(tbg$fpkm, retx = TRUE, center = TRUE, scale. = TRUE))
?svd
plot(prcomp(tbg$fpkm, retx = TRUE, center = TRUE, scale. = FALSE))
setwd("~/MyGithub/BasePop_RNAseq/base_pop/scripts")
knitr::opts_chunk$set(echo = TRUE)
library("DESeq2")
library(dplyr)
library(stringr)
countdata <- as.matrix(read.csv("../../processed/transcript_count_matrix.csv", row.names="gene_id"))
setwd("~/MyGithub/BasePop_RNAseq/base_pop/scripts/DESeq_scripts")
countdata <- as.matrix(read.csv("../../processed/transcript_count_matrix.csv", row.names="gene_id"))
countdata <- as.matrix(read.csv("../../processed/gene_count_matrix.csv", row.names="gene_id"))
head(countdata)
phenDat <- read.csv("../../processed/describe_samplesDE.csv", stringsAsFactors = FALSE)
names(phenDat)[1]<-"ids"
phenDat <- phenDat %>%
select(ids,treatment,tissue)
head(phenDat)
628/12
2686/12
1913*2
3580/12
12230/12
library(tidyverse)
?geom_point
library(ggplot2)
args(name = ggplot2::filter)
args(name = dplyr::filter)
library(DESeq2)
args(name = DESeq2::DESeqDataSetFromMatrix)
DESeqDataSetFromMatrix
devtools::install_github("r-lib/conflicted")
library(conflicted)
342/50
1974+62
62/27
x <- 62/27
x*10000
y <- x*10000
y/365.25
44+18
2018+18
44+65
44+21
2018+21
44+26
2018+26
44+23
2018+23
25*15
125*12
23.12+4.99+3.99+3.99+14.99
