---
title: "Prep DESeq-worthy counts from StringTie output"
author: "Enoch Ng'oma"
date: "7/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(DESeq2)
library(dplyr)
library(stringr)
library(sva)
library(ggplot2)
library(limma)
library(RColorBrewer)

set.seed(38142903)
```

# Get more gene_ids from StringTie object with python: https://www.biostars.org/p/261128/

# Ref: http://ccb.jhu.edu/software/stringtie/index.shtml?t=manual#de
# Ref p.92-93 Haddok & Dunn book
# Detailed instructions are in /scripts/DESeq_scripts/prepDEpy_instructions.txt

# Load gene(/transcript) count matrix and labels

```{r}
countdata <- read.csv("../../processed/gene_count_matrix.csv", row.names="gene_id")

# Reformat column names
names(countdata) = sub("\\.","",names(countdata)) #regex escape the escape
countdata <- as.matrix(countdata)

phenDat <- read.csv("../../processed/describe_samplesDE.csv", stringsAsFactors = FALSE)
names(phenDat)[1]<-"ids"
phenDat <- phenDat %>%
  select(ids,treatment,tissue)

rownames(phenDat) <- phenDat[,1]
phenDat[,1] <- NULL

#colData <- pData(phenDat)[,c("treatment","tissue")]
phenDat <- as.matrix(phenDat)

# Check all sample IDs in colData are also in CountData and match their orders
all(rownames(phenDat) %in% colnames(countdata))
countdata <- countdata[, rownames(phenDat)]
all(rownames(phenDat) == colnames(countdata))
```

# Model with treatment and tissue
# DESeq vs Ballgown, see https://support.bioconductor.org/p/107011/

```{r}
# Create a DESeqDataSet from count matrix and labels
dds <- DESeqDataSetFromMatrix(countData = countdata,
colData = phenDat, design = ~ tissue + treatment)

# Run the default analysis for DESeq2 and generate results table

#ddsDE <- DESeq(dds)
#res <- results(ddsDE)

#Sort by adjusted p-value and display
#(resOrdered <- res[order(res$padj), ]) 

#save(ddsDE, file = "../../processed/DESEQ/ddsDE.Rda")
#save(resOrdered, file = "../../processed/DESEQ/resOrdered.Rda")

```

# Model with treatment, tissue and interaction

```{r}
dds2 <- DESeqDataSetFromMatrix(countData = countdata,
colData = phenDat, design = ~ tissue + treatment + tissue*treatment)

# Run the default analysis for DESeq2 and generate results table

#ddsDE2 <- DESeq(dds2)
#res2 <- results(ddsDE2)

#Sort by adjusted p-value and display
#(resOrdered2 <- res2[order(res2$padj), ]) 

#save(ddsDE2, file = "../../processed/DESEQ/ddsDE2.Rda")
#save(resOrdered2, file = "../../processed/DESEQ/resOrdered2.Rda")
```

# Control for batch effects with sva

```{r}
dds.sva <- estimateSizeFactors(dds)
dat.sva <- counts(dds.sva, normalized=TRUE)
cc.c <- rowSums(dat.sva)

#remove all genes with 0s for all samples
dat.sva <- dat.sva[which(cc.c>0),]

phenDat.sva <- read.csv("../../processed/describe_samples_batch.csv", stringsAsFactors = FALSE)
names(phenDat.sva)[5]<-"batch"
#cbind(phenDat.sva, colnames(dat.sva))

mod <- model.matrix(~as.factor(treatment)* 
                              as.factor(tissue) + 
                              as.factor(batch), 
                              data=phenDat.sva)

mod0 <- model.matrix(~as.factor(batch), data=phenDat.sva) 

# calculate number of surrogate variables
n.sv <- num.sv(dat.sva, mod, method = "be")
print(c("Calculated number of significant SVs = ", n.sv))

svobj <- svaseq(dat.sva, mod, mod0, n.sv=n.sv) 

phenDat.sva$SV1 <- svobj$sv[,1]
phenDat.sva$SV2 <- svobj$sv[,2]

ggplot(phenDat.sva, aes(x=SV1, y=SV2)) +
  geom_point(alpha=1/5, size=3)
```

# DESeq on batch-controlled data
# Model without interaction

```{r}
countdata <- read.csv("../../processed/gene_count_matrix.csv", row.names="gene_id")

# Reformat column names
names(countdata) = sub("\\.","",names(countdata)) #regex escape the escape
countdata <- as.matrix(countdata)

phenDat.sva <- phenDat.sva %>%
  select(id,treatment,tissue,batch,SV1,SV2)

rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL

# Reformat column names
rownames(phenDat.sva) = sub("\\-","",rownames(phenDat.sva)) #regex escape the escape
#phenDat.sva <- as.matrix(phenDat.sva)

#rp = rownames(phenDat.sva)
#rp[duplicated(rp)]

# countData colnames() must be identical to colData rownames()
all(rownames(phenDat.sva) %in% colnames(countdata))
countdata <- countdata[, rownames(phenDat.sva)]
all(rownames(phenDat.sva) == colnames(countdata))

phenDat.sva$batch <- as.factor(phenDat.sva$batch)
phenDat.sva$treatment <- as.factor(phenDat.sva$treatment)
phenDat.sva$tissue <- as.factor(phenDat.sva$tissue)

# DESeqDataSet for all variables, no interaction
dds.ttSS <- DESeqDataSetFromMatrix(countData = countdata, 
                                   colData = phenDat.sva, 
                                   design = ~ SV1 + SV2 + batch + tissue + treatment)

dds_deseq <- DESeq(dds.ttSS)
res.dds <- results(dds_deseq)
(res.dds <- res.dds[order(res.dds$padj), ])

# 22 rows did not converge

## Merge with normalized count data
res.dds_table <- merge(as.data.frame(res.dds), 
                       as.data.frame(counts(dds_deseq, normalized=TRUE)), 
                       by="row.names", sort=FALSE)
names(res.dds_table)[1] <- "Gene"

save(dds_deseq, file = "../../processed/DESEQ/dds_deseq.Rda")
save(res.dds_table, file = "../../processed/DESEQ/DEseqSVA_Noint_resOrdered_padj.Rda")

write.csv(res.dds_table, 
          "../../processed/DESEQ/DEseqSVA_Noint_resOrdered_padj.csv", row.names=TRUE)

load("../../processed/DESEQ/DEseqSVA_Noint_resOrdered_padj.Rda")

# Examine plot of p-values
hist(res.dds$pvalue, breaks=50, col="grey")

# Examine independent filtering
metadata(res.dds)$filterThreshold

plot(metadata(res.dds)$filterNumRej, type="b", xlab="quantiles of baseMean", ylab="number of rejections")
```

# MA plot

```{r}
load("../../processed/DESEQ/DEseqSVA_Noint_resOrdered_padj.Rda")

# Could do with built-in DESeq2 function:
DESeq2::plotMA(dds_deseq, ylim=c(-1,1))

# Alternatively
maplot <- function (res.dds_table, thresh=0.05, labelsig=TRUE, textcx=1, ...) {
  with(res.dds_table, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
  with(subset(res.dds_table, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
  if (labelsig) {
    require(calibrate)
    with(subset(res.dds_table, padj<thresh), textxy(baseMean, log2FoldChange, labs="Gene", cex=textcx, col=2))
  }
}
png("diffexpr-maplot.png", 1500, 1000, pointsize=20)
maplot(res.dds_table, ylim=c(-2,2), main="MA Plot")
dev.off()

# see all results available
resultsNames(dds_deseq)

#resDR_C <- results(dds_deseq, "treatment_DR_vs_C")
results(dds_deseq, contrast=c("treatment","C","DR"))
```

# Volcano plot

```{r}
load("../../processed/DESEQ/DEseqSVA_Noint_resOrdered_padj.Rda")

par(mar=c(5,5,5,5), cex=1.0, cex.main=1.4, cex.axis=1.4, cex.lab=1.4)

topT <- as.data.frame(res.dds_table)

#Adjusted P values (FDR Q values)
with(topT, plot(log2FoldChange, -log10(padj), pch=20, main="Volcano plot", cex=1.0, xlab=bquote(~Log[2]~fold~change), ylab=bquote(~-log[10]~Q~value)))

with(subset(topT, padj<0.05 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(padj), pch=20, col="red", cex=0.5))

#with(subset(topT, padj<0.05 & abs(log2FoldChange)>2), text(log2FoldChange, -log10(padj), labels=subset(rownames(topT), topT$padj<0.05 & abs(topT$log2FoldChange)>2), cex=0.8, pos=3))

#Add lines for absolute FC>2 and P-value cut-off at FDR Q<0.05
abline(v=0, col="black", lty=3, lwd=1.0)
abline(v=-2, col="black", lty=4, lwd=2.0)
abline(v=2, col="black", lty=4, lwd=2.0)
abline(h=-log10(max(topT$pvalue[topT$padj<0.05], na.rm=TRUE)), col="black", lty=4, lwd=2.0)
```

```{r}
dev.off()
with(res.dds_table, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-5,5), ylim=c(0,25)))

# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(res.dds_table, padj<.05 ), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
with(subset(res.dds_table, abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="orange"))
with(subset(res.dds_table, padj<.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="green"))

# Label points with the textxy function from the calibrate plot
library(calibrate)
with(subset(res.dds_table, padj<.05 & abs(log2FoldChange)>1), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=.8))
```

# Subset tissues

```{r}
load("../../processed/DESEQ/DEseqSVA_Noint_resOrdered_padj.Rda")

# Bodies
grep_body <- grep("_B",colnames(res.dds_table))
res.dds_body <- res.dds_table[,grep_body]

# Heads
grep_head <- grep("_H",colnames(res.dds_table))
res.dds_head <- res.dds_table[,grep_head]

# Ovaries
grep_ovary <- grep("_O",colnames(res.dds_table))
res.dds_ovary <- res.dds_table[,grep_ovary]

```

# Model with interactions

```{r}
dds.int <- DESeqDataSetFromMatrix(countData = countdata, 
                                   colData = phenDat.sva, 
                                   design = ~ SV1 + SV2 + batch + tissue + treatment + 
                                    tissue*treatment)

dds_int <- DESeq(dds.int)
# 205 rows not converged!

res_int <- results(dds_int)
(resOrd_int <- res_int[order(res_int$padj), ])

save(dds, file = "../../processed/DESEQ/DEseq_sva_int.Rda")
write.csv(resOrd_int, 
          "../../processed/DESEQ/DEseqSVA_int_resOrdered_padj.csv", row.names=TRUE)




# Comparisons across treatment levels
resultsNames(dds_int)

# C vs DR
cdr.int <- results(dds_deseq, contrast=c("treatment","C","DR"))
mcols(cdr.int) # mcols = metadata columns, i.e. element-wise metadata
(resOrd_cdrint <- cdr.int[order(cdr.int$padj), ])
write.csv(resOrd_cdrint, 
          "../../processed/DESEQ/CvDR_DEseqSVA_int_resOrdered_padj.csv", row.names=TRUE)

#C vs HS
hs.int <- results(dds_deseq, contrast=c("treatment","C","HS"))
(resOrd_hsint <- hs.int[order(hs.int$padj), ])

write.csv(resOrd_hsint, 
          "../../processed/DESEQ/CvHS_DEseqSVA_int_resOrdered_padj.csv",
          row.names=TRUE)
```

# Filtering low abundance reads
# Note: https://www.biostars.org/p/320132/

```{r}
# Filter step not necessary; default in results() - see ?results, but enhances speed https://support.bioconductor.org/p/65256/
#filter <- rowSums(nc >= 10) >= 5 # at least 10 reads in at least 5 samples

# Increase the maximum iterations (maxit) instead of running DESeq()
#dds <- estimateSizeFactors(ddsDE_filt)
#dds <- estimateDispersions(dds)
#dds <- nbinomWaldTest(dds, maxit=20000)

# To remove the non-converging rows
#ddsClean <- dds[which(mcols(dds)$betaConv),]
```






# Data transformation - the Love et al (2014) tutorial way
# Note: data will no longer be counts
# rlog is very similar to regularization in DESeq() and nbinomWaldTest()

```{r}
rld <- rlogTransformation(dds_deseq, blind=TRUE) #time intensive
vsd <- varianceStabilizingTransformation(dds_deseq, blind = TRUE)

library(vsn) # Bioconductor
library(hexbin)

# Regularized log transformation
par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds_deseq))>0)
meanSdPlot(log2(counts(dds_deseq, normalized=TRUE)[notAllZero,]+1),
           ylim = c(0,2.5))
meanSdPlot(assay(rld[notAllZero,]), ylim = c(0,2.5))
meanSdPlot(assay(vsd[notAllZero,]), ylim = c(0,2.5))

# Variance stabilizing transformation

# Dispersion plot (parametric - recommended)
plotDispEsts(dds_deseq)

# Local dispersion fit (if parametric does not converge)
#ddsLocal <- estimateDispersions(dds_deseq, fitType="local")
# third alternative: mean dispersion

```

# Data quality assessment - clustering & visualization

```{r}
# Heatmap of count table
library(gplots)

#use a DESeq()-ready data object
Select <- order(rowMeans(counts(dds_deseq, normalized=TRUE)), 
                decreasing=TRUE)[1:30]
hmcol <- colorRampPalette(brewer.pal(9, "GnBu"))(100)

heatmap.2(counts(dds_deseq, normalized=TRUE)[Select,], col = hmcol,
          Rowv = FALSE, Colv = FALSE, scale = "none",
          dendrogram = "none", trace = "none", margin = c(10,6))

dev.off()
heatmap.2(assay(rld)[Select,], col = hmcol,
          Rowv = FALSE, Colv = FALSE, scale = "none",
          dendrogram = "none", trace = "none", margin = c(10,6))

dev.off()
heatmap.2(assay(vsd)[Select,], col = hmcol,
          Rowv = FALSE, Colv = FALSE, scale = "none",
          dendrogram = "none", trace = "none", margin = c(10,6))

# Heatmap of the sample-sample distance
dev.off()
distRL <- dist(t(assay(rld)))
Matt <- as.matrix(distRL)
rownames(Matt) <- colnames(Matt) <- with(colData(dds_deseq),
                                         paste(treatment, tissue, sep=":"))
heatmap.2(Matt, trace = "none", col = rev(hmcol), margin=c(8,8))


# PCA of samples
# different ways to visualize
dev.off()
print(plotPCA(rld, intgroup=c("treatment", "tissue")))
plotPCA(rld, intgroup=c("treatment"), returnData=FALSE)

rld.sub <- rld[ , rld$tissue %in% c("O", "B", "H") ]
plotPCA(rld.sub, "tissue")

rld.sub<-rld[,rld@colData@listData$treatment %in% c("C","HS", "DR")]
plotPCA(rld.sub, "treatment")

# Visualize p-value optimization
attr(res.dds, "filterThreshold")
attr(res_int, "filterThreshold")

#NULL could mean too many DEs & independent (default in results()), filtering did not happen. Solution:

metadata(res.dds)$filterThreshold
metadata(res_int)$filterThreshold

plot(attr(res.dds, "filterNumRej"), type="b",
     xlab="quantiles of 'baseMean'",
     ylab="number of rejections")

# turn off independent filtering and see what happens
resNoFilt <- results(dds_deseq, independentFiltering = FALSE)
table(filtering=(res.dds$padj < 0.1), noFiltering=(resNoFilt$padj < 0.1))

# turn on independent filtering and see what happens
rv <- rowVars(counts(dds_deseq, normalized=TRUE))
resFiltByVar <- results(dds_deseq, filter = rv)
table(rowMean=(res.dds$padj < 0.1), rowVar=(resFiltByVar$padj < 0.1))
```



