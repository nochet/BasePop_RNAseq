---
title: "Prep DESeq-worthy counts from StringTie output"
author: "Enoch Ng'oma"
date: "7/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(DESeq2)
library(dplyr)
library(stringr)
library(sva)
library(ggplot2)
library(limma)

set.seed(38142903)
```

# Get more gene_ids from StringTie object with python: https://www.biostars.org/p/261128/

# Ref: http://ccb.jhu.edu/software/stringtie/index.shtml?t=manual#de
# Ref p.92-93 Haddok & Dunn book
# Detailed instructions are in /scripts/DESeq_scripts/prepDEpy_instructions.txt

# Load gene(/transcript) count matrix and labels

```{r}
countdata <- read.csv("../../processed/gene_count_matrix.csv", row.names="gene_id")

# Reformat column names
names(countdata) = sub("\\.","",names(countdata)) #regex escape the escape
countdata <- as.matrix(countdata)

phenDat <- read.csv("../../processed/describe_samplesDE.csv", stringsAsFactors = FALSE)
names(phenDat)[1]<-"ids"
phenDat <- phenDat %>%
  select(ids,treatment,tissue)

rownames(phenDat) <- phenDat[,1]
phenDat[,1] <- NULL

#colData <- pData(phenDat)[,c("treatment","tissue")]
phenDat <- as.matrix(phenDat)

# Check all sample IDs in colData are also in CountData and match their orders
all(rownames(phenDat) %in% colnames(countdata))
countdata <- countdata[, rownames(phenDat)]
all(rownames(phenDat) == colnames(countdata))
```

# Model with treatment and tissue
# DESeq vs Ballgown, see https://support.bioconductor.org/p/107011/

```{r}
# Create a DESeqDataSet from count matrix and labels
dds <- DESeqDataSetFromMatrix(countData = countdata,
colData = phenDat, design = ~ tissue + treatment)

# Run the default analysis for DESeq2 and generate results table

#ddsDE <- DESeq(dds)
#res <- results(ddsDE)

#Sort by adjusted p-value and display
#(resOrdered <- res[order(res$padj), ]) 

#save(ddsDE, file = "../../processed/DESEQ/ddsDE.Rda")
#save(resOrdered, file = "../../processed/DESEQ/resOrdered.Rda")

```

# Model with treatment, tissue and interaction

```{r}
dds2 <- DESeqDataSetFromMatrix(countData = countdata,
colData = phenDat, design = ~ tissue + treatment + tissue*treatment)

# Run the default analysis for DESeq2 and generate results table

#ddsDE2 <- DESeq(dds2)
#res2 <- results(ddsDE2)

#Sort by adjusted p-value and display
#(resOrdered2 <- res2[order(res2$padj), ]) 

#save(ddsDE2, file = "../../processed/DESEQ/ddsDE2.Rda")
#save(resOrdered2, file = "../../processed/DESEQ/resOrdered2.Rda")
```

# Control for batch effects with sva

```{r}
dds.sva <- estimateSizeFactors(dds)
dat.sva <- counts(dds.sva, normalized=TRUE)
cc.c <- rowSums(dat.sva)

#remove all genes with 0s for all samples
dat.sva <- dat.sva[which(cc.c>0),]

phenDat.sva <- read.csv("../../processed/describe_samples_batch.csv", stringsAsFactors = FALSE)
names(phenDat.sva)[5]<-"batch"
#cbind(phenDat.sva, colnames(dat.sva))

mod <- model.matrix(~as.factor(treatment)* 
                              as.factor(tissue) + 
                              as.factor(batch), 
                              data=phenDat.sva)

mod0 <- model.matrix(~as.factor(batch), data=phenDat.sva) 

# calculate number of surrogate variables
n.sv <- num.sv(dat.sva, mod, method = "be")
print(c("Calculated number of significant SVs = ", n.sv))

svobj <- svaseq(dat.sva, mod, mod0, n.sv=n.sv) 

phenDat.sva$SV1 <- svobj$sv[,1]
phenDat.sva$SV2 <- svobj$sv[,2]

ggplot(phenDat.sva, aes(x=SV1, y=SV2)) +
  geom_point(alpha=1/5, size=3)
```

# DESeq on batch-controlled data

```{r}
countdata <- read.csv("../../processed/gene_count_matrix.csv", row.names="gene_id")

# Reformat column names
names(countdata) = sub("\\.","",names(countdata)) #regex escape the escape
countdata <- as.matrix(countdata)

phenDat.sva <- phenDat.sva %>%
  select(id,treatment,tissue,batch,SV1,SV2)

rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL

# Reformat column names
rownames(phenDat.sva) = sub("\\-","",rownames(phenDat.sva)) #regex escape the escape
#phenDat.sva <- as.matrix(phenDat.sva)

#rp = rownames(phenDat.sva)
#rp[duplicated(rp)]

# countData colnames() must be identical to colData rownames()
all(rownames(phenDat.sva) %in% colnames(countdata))
countdata <- countdata[, rownames(phenDat.sva)]
all(rownames(phenDat.sva) == colnames(countdata))

phenDat.sva$batch <- as.factor(phenDat.sva$batch)
phenDat.sva$treatment <- as.factor(phenDat.sva$treatment)
phenDat.sva$tissue <- as.factor(phenDat.sva$tissue)

# DESeqDataSet for all variables
dds.ttSS <- DESeqDataSetFromMatrix(countData = countdata, 
                                   colData = phenDat.sva, 
                                   design = ~ SV1 + SV2 + batch + tissue + treatment)

dds_deseq <- DESeq(dds.ttSS)
res.dds <- results(dds_deseq)
(res.dds <- res.dds[order(res.dds$padj), ])

save(dds, file = "../../processed/DESEQ/DEseq_sva_dds.Rda")
```

# Filtering low abundance reads
# Note: https://www.biostars.org/p/320132/

```{r}
# Filter step not necessary; default in results() - see ?results, but enhances speed https://support.bioconductor.org/p/65256/
#filter <- rowSums(nc >= 10) >= 5 # at least 10 reads in at least 5 samples

# Increase the maximum iterations (maxit) instead of running DESeq()
#dds <- estimateSizeFactors(ddsDE_filt)
#dds <- estimateDispersions(dds)
#dds <- nbinomWaldTest(dds, maxit=20000)

# To remove the non-converging rows
#ddsClean <- dds[which(mcols(dds)$betaConv),]
```

# DESeq2 3-factor conditions: https://www.biostars.org/p/115685/ (LRT is akin 1-WAY ANOVA)

```{r}
load("../../processed/DESEQ/DEseq_sva_dds.Rda")

# see all results available
resultsNames(dds_deseq)


resDR_C <- results(dds_deseq, "batch_3_vs_1")

```

```{r}
design(dds) = ~ group
dds = DESeq(dds, test = "LRT", reduced = ~ 1)
results(dds)
```

```{r}

```

