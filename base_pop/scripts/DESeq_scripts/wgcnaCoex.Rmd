---
title: "WGCNA clustering"
author: "Enoch Ng'oma"
date: "2/5/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Tutorials
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# https://wikis.utexas.edu/display/bioiteam/Clustering+using+WGCNA
# https://bioconductor.org/packages/release/bioc/vignettes/CVE/inst/doc/WGCNA_from_TCGA_RNAseq.html


library(WGCNA)
#library(DESeq2)
library(flashClust)
library(ape)
#library(limma)

options(stringsAsFactors = FALSE)
allowWGCNAThreads()
#disableWGCNAThreads()

set.seed(341072)
```

# Data

```{r}
# countdata <- read.csv("../../processed/DESEQ/Expr_countData.csv")
# rownames(countdata) <- countdata[,1]
# countdata[,1] <- NULL
# countdata <- as.matrix(countdata)

phenDat.sva <- read.csv("../../processed/DESEQ/sampleDat_with_SV.csv")
rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL
phenDat.sva$treat_tissue <- paste(phenDat.sva$treatment,"_",phenDat.sva$tissue, sep="")

load("../../processed/DESEQ/dds_deseq01.Rda")
```

# DESeq object

```{r}
# dds <- DESeqDataSetFromMatrix(countData = countdata, 
#                               colData = phenDat.sva, 
#                               design = ~ SV1 + batch + tissue + treatment)
# 
# dds.wg <- estimateSizeFactors(dds)
# nc <- counts(dds.wg, normalized=TRUE)
# filter <- rowSums(nc >= 10) >= 2
# dds.wg <- dds.wg[filter,]
# dds.wg <- estimateDispersions(dds.wg, fitType = "local")
# dds.wg <- nbinomWaldTest(dds.wg, maxit = 1000, useOptim = TRUE)
# 
# dds.wgg <- DESeqDataSetFromMatrix(countData = countdata, 
#                               colData = phenDat.sva, 
#                               design = ~ SV1 + batch + tissue)
# 
# dds.wg1 <- estimateSizeFactors(dds.wgg)
# nc <- counts(dds.wg1, normalized=TRUE)
# filter <- rowSums(nc >= 10) >= 2
# dds.wg1 <- dds.wg1[filter,]
# dds.wg1 <- estimateDispersions(dds.wg1, fitType = "local")
# dds.wg1 <- nbinomWaldTest(dds.wg1, maxit = 1000, useOptim = TRUE)

```

# rlog transform exprs data

```{r}
# rlog.wg1 <- rlog(dds.wg1, blind = TRUE, fitType = "parametric")
# #save(rlog.wg1, file = "../../processed/DESEQ/rlog.wg1.Rda")
# write.table(assay(rlog.wg1), 
#             file="../../processed/DESEQ/rlog.wg1.txt", 
#             sep="\t")
# 
# rlog.trt <- read.table("../../processed/DESEQ/rlog.wg1.txt", 
#                        sep = "\t", stringsAsFactors = FALSE)
```

# Compute means across replicates

```{r}
# # Prep a vector of column names
# sampdat <- read.csv("../../processed/DESEQ/sampleDat_with_SV.csv")
# sampdat$treat_tissue <- paste(sampdat$treatment,"_",sampdat$tissue, sep="")
# sampdat <- sampdat[order(sampdat[,2], sampdat[,3]), ]
# 
# # Sort columns
# col_order <- sampdat[,'X']
# rlog.trt <- rlog.trt[, col_order]
# #rlog.trt = as.data.frame(t(rlog.trt)) 
# dim(rlog.trt) 
# 
# # Number of rows per group 
# n <- 6
# 
# # Number of groups
# n_grp <- nrow(rlog.trt) / n
# 
# # Column indices (one vector per group)
# idx_grp <- split(seq(rlog.trt), rep(seq(n_grp), each = n))
# 
# # Calculate the row means for all groups
# rlog.avg <- lapply(idx_grp, function(i) {
#     # subset of the data frame
#     tmp <- rlog.trt[i]
#     # calculate row means
#     rowMeans(tmp, na.rm = TRUE)
# })
# rlog.avg <- as.data.frame(rlog.avg)
# 
# # Grab names of first column of each group
# names_frst <- names(rlog.trt)[sapply(idx_grp, "[", 1)]
# 
# # Modify column names of new data frame
# names(rlog.avg) <- names_frst

```

# WGCNA Preliminaries

```{r}
rlog.01 <- read.table("../../processed/DESEQ/rlog.01.txt", 
            sep="\t", stringsAsFactors = FALSE)

# get data into WGCNA format - genes as columns, samples as rows
rlogtrt = as.data.frame(t(rlog.01)) 
dim(rlogtrt) 

# Check gene outliers
outls = goodSamplesGenes(rlogtrt, verbose = 3)
outls$allOK 

```

# Cluster samples to check outliers

```{r}
sampleTree = hclust(dist(rlogtrt), method = "average");

sizeGrWindow(12,9) # inches
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)
```

# Select soft power

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
sft = pickSoftThreshold(rlogtrt, powerVector=powers, 
                        verbose =5, 
                        networkType="signed")
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

abline(h=0.90, col="red")

plot(sft$fitIndices[,1], sft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")
 
# Choose a power lowest power for which the scale free topology index reaches 0.90
```

# Construct a gene co-expression matrix and generate modules
# softPower threshold explained here: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

```{r}
# Build a adjacency "correlation" matrix
enableWGCNAThreads()
softPower = 19
adjacency = adjacency(rlogtrt, 
                      power=softPower, 
                      type="signed")
#specify signed network type
head(adjacency)
 
# Translate the adjacency into topological overlap matrix (TOM) and calculate the corresponding dissimilarity:

TOM = TOMsimilarity(adjacency, TOMType="signed") # specify network type
dissTOM = 1-TOM

```

# Generate modules

```{r}
# Create gene tree by average linkage hierarchical clustering 
geneTree = flashClust(as.dist(dissTOM), method="average")
plot(geneTree, xlab="", sub="", 
     main= "Gene Clustering on TOM-based dissimilarity", 
     labels= FALSE, hang=0.04)

# Set minimum number of genes in a module
minModuleSize = 30

# Module identification using dynamic tree cut algorithm
dynamicMods = cutreeDynamic(dendro= geneTree, 
                            distM= dissTOM, deepSplit=2,
                            pamRespectsDendro= FALSE, 
                            minClusterSize = minModuleSize,
                            verbose = 2)
# Modules identified
table(dynamicMods)

# Assign module colours
dynamicColors= labels2colors(dynamicMods)

# Plot dendrogram of igengenes
plotDendroAndColors(geneTree, dynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')
```

# Merge modules whose expression profiles are very similar

```{r}
# Calculate eigengenes
MEList= moduleEigengenes(rlogtrt, 
                         colors= dynamicColors,
                         softPower = softPower)
                         
MEs= MEList$eigengenes;

# Calculate dissimilarity of module eigengenes
MEDiss= 1-cor(MEs);

# Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")

# Plot the module tree with phytools package
par(mar=c(2,2,2,2))

plot.phylo(as.phylo(METree),type = 'fan',
           show.tip.label = FALSE, main='')
tiplabels(frame = 'circle',col='black',
          text=rep('',length(unique(dynamicMods))), 
          bg = levels(as.factor(dynamicColors)))

# Plot with WGCNA
sizeGrWindow(7,6)
plot(METree, main = "clustering of module eigengene",
     xlab = "", sub = "")

save(dynamicMods, MEList, MEs, MEDiss, METree, file= "../../processed/DESEQ/Network_allSamples_signed_RLDfiltered.RData")
```

# Merge at a selected threshold

```{r}
# Set threshold for merging modules 
# Can choose no merge i.e. MEDissThres=0.0)
# A height cut of 0.25, corresponds to correlation of 0.75
MEDissThres = 0.25
abline(h=MEDissThres, col ="red")

# Call automatic merging function
merge = mergeCloseModules(rlogtrt, 
                          dynamicColors, 
                          cutHeight= MEDissThres, 
                          verbose =3)
mergedColors = merge$colors;
mergedMEs = merge$newMEs;
#dev.off()

# Plot dendrogram with module colors below it
#pdf(file="../../plots/cluster.pdf")
plotDendroAndColors(geneTree, 
                    cbind(dynamicColors, mergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
#dev.off()

# Rename to moduleColors
moduleColors = mergedColors

# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;

save(MEs, moduleLabels, moduleColors, geneTree, 
     file= "../../processed/DESEQ/Network_allSamples_signed_merge.RData")

```

# Visualize weighted network via heatmap

```{r}
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^20;

# Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;

# Call the plot function
pdf(file = "../../plots/weighted_heat.pdf", wi = 6, he = 6)

sizeGrWindow(6,6)
TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")

dev.off()

# For 400 genes
nSelect = 400
# For reproducibility, we set the random seed
set.seed(10);
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

select = sample(nGenes, size = nSelect);
selectTOM = dissTOM[select, select];

# Thereâ€™s no simple way to restrict tree to a subset of genes, so must re-cluster
selectTree = hclust(as.dist(selectTOM), method = "average")
selectColors = moduleColors[select];

pdf(file = "../../plots/weighted_heat.pdf", wi = 7, he = 7)
sizeGrWindow(7,7)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^20;
diag(plotDiss) = NA;
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap, 400 genes")
dev.off()
```

# Visualize relationships between modules

```{r}

```

# Relate gene expression modules to sample traits
# https://peterlangfelder.com/2018/11/25/working-with-categorical-variables/

```{r}
# Sample info
phenDat <- read.csv("../../processed/describe_samples.csv")
names(phenDat)
rownames(phenDat) <- phenDat[,1]
phenDat[,1] <- NULL
head(phenDat)
phenDat <- phenDat[,1]

# Binarize categorical variable into pairwise indicators
phen.bin = binarizeCategoricalVariable(phenDat,
includePairwise = TRUE,
includeLevelVsAll = FALSE,
dropUninformative = TRUE,
includeLevelInformation = TRUE);
# Print the variable and the indicators
data.frame(phenDat,phen.bin);

# rlog-transformed exprs data
rlogtrt <- read.table("../../processed/DESEQ/rlog.01.txt", 
                       sep = "\t",
                       stringsAsFactors = FALSE)

# Check and order sample IDs to match exprs ids
# all(rownames(phen.bin) %in% colnames(rlogtrt))
# rlogtrt <- rlogtrt[, rownames(phen.bin)]
# all(rownames(phen.bin) == colnames(rlogtrt))

rlogtrt = as.data.frame(t(rlogtrt)) 
dim(rlogtrt) 

# Correlate traits 
# Define number of genes and samples
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

# Recalculate MEs with color labels
MEs0 = moduleEigengenes(rlogtrt, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, phen.bin, use= "p") 
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)

# Print correlation heatmap between modules and traits
textMatrix= paste(signif(moduleTraitCor, 2), 
                  signif(moduleTraitPvalue, 1), ")", sep= "")
dim(textMatrix)= dim(moduleTraitCor)

par(mar= c(1, 1, 2, 2))

# Heatmap plot of corelation values 
labeledHeatmap(Matrix= moduleTraitCor,
            xLabels= moduleTraitCor,
            yLabels= names(MEs),
            ySymbols= names(MEs),
            colorLabels= TRUE,
            colors= blueWhiteRed(50),
            textMatrix= textMatrix,
            setStdMargins= FALSE,
            cex.text= 0.5,
            zlim= c(-1,1),
            main= paste("Module-trait relationships"))
```

