---
title: "WGCNA clustering"
author: "Enoch Ng'oma"
date: "2/5/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Tutorials
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# https://wikis.utexas.edu/display/bioiteam/Clustering+using+WGCNA
# https://bioconductor.org/packages/release/bioc/vignettes/CVE/inst/doc/WGCNA_from_TCGA_RNAseq.html

library(flashClust)
library(WGCNA)
library(ape)

options(stringsAsFactors = FALSE)
allowWGCNAThreads()
#disableWGCNAThreads()

library(DESeq2)
library(limma)
library(tidyverse)
library(cowplot)

set.seed(341072)
```

# Data

```{r}
countdata <- read.csv("../../processed/DESEQ/Expr_countData.csv")
rownames(countdata) <- countdata[,1]
countdata[,1] <- NULL
countdata <- as.matrix(countdata)

phenDat.sva <- read.csv("../../processed/DESEQ/sampleDat_with_SV.csv")
rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL
phenDat.sva$batch <- as.factor(phenDat.sva$batch)
phenDat.sva$treat_tissue <- paste(phenDat.sva$treatment,"_",phenDat.sva$tissue, sep="")
```

# DESeq object

```{r}
# dd0 <- DESeqDataSetFromMatrix(countData = countdata,
#                               colData = phenDat.sva,
#                               design = ~ SV1 + batch)
# 
# dd0.wg <- estimateSizeFactors(dd0)
# nc <- counts(dd0.wg, normalized=TRUE)
# filter <- rowSums(nc >= 10) >= 2
# 
# # log transform null DESeq model: design ~ SV1 + batch
# rlog.wg0 <- rlog(dd0.wg[filter,], blind = FALSE, fitType = "parametric")
# vst.wg0 <- varianceStabilizingTransformation(dd0.wg[filter,], 
#                                              blind = FALSE, fitType = "parametric")

# rlog transformation of full model
# load("../../processed/DESEQ/dds_deseq01.Rda")
# 
# rlog.wg1 <- rlog(dds_deseq.01, blind = FALSE, fitType = "parametric")
# write.table(assay(rlog.wg1),
#             file="../../processed/DESEQ/rlog.wg1.txt",
#             sep="\t")

# log transform full DESeq model: design ~ SV1 + batch + tissue + treatment
# rlog.wg1 <- rlog(rlog.wg1, blind = FALSE, fitType = "parametric")

# save for comparison
# write.table(assay(vst.w),
#             file="../../processed/DESEQ/vst.w.txt",
#             sep="\t")
# write.table(vst.wg0,
#             file="../../processed/DESEQ/vst.wg0.txt",
#             sep="\t")

rlog.wg0 <- read.table("../../processed/DESEQ/rlog.wg0.txt",
            sep="\t", stringsAsFactors = FALSE)
vst.wg0 <- read.table("../../processed/DESEQ/vst.wg0.txt",
            sep="\t", stringsAsFactors = FALSE)
rlog.wg1 <- read.table("../../processed/DESEQ/rlog.wg1.txt", 
            sep="\t", stringsAsFactors = FALSE)

rlog.wg1[1:2,1:4]
rlog.wg0[1:2,1:4]
vst.wg0[1:2,1:4]

boxplot(rlog.wg0)
boxplot(vst.wg0)
```

# WGCNA Preliminaries

```{r}

# Get data into WGCNA format - genes as columns, samples as rows
rlogtrt = as.data.frame(t(rlog.wg0)) 
dim(rlogtrt) 

# Check gene outliers or too many missing values
outls = goodSamplesGenes(rlogtrt, verbose = 3)
outls$allOK 

# Sample data to numerical format
phenDat.sva$trt_tis <- ifelse(phenDat.sva$treat_tissue == "C_B",1, 
                          ifelse(phenDat.sva$treat_tissue=="C_H",2,
                          ifelse(phenDat.sva$treat_tissue=="C_O",3,
                          ifelse(phenDat.sva$treat_tissue=="DR_B",4,
                          ifelse(phenDat.sva$treat_tissue=="DR_H",5,
                          ifelse(phenDat.sva$treat_tissue=="DR_O",6,
                          ifelse(phenDat.sva$treat_tissue=="HS_B",7,
                          ifelse(phenDat.sva$treat_tissue=="HS_H",8, 9))))))))
```

# Cluster samples to check outliers

```{r}
sampleTree = hclust(dist(rlogtrt), method = "average");

sizeGrWindow(12,9) # inches
par(cex = 0.6);
par(mar = c(0,4,2,0))

plot(sampleTree, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

```

# Select soft power

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
sft = pickSoftThreshold(rlogtrt, powerVector=powers, 
                        corFnc = cor, # see FAQ point 3
                        networkType="signed",
                        verbose =5)
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

abline(h=0.90, col="red")

plot(sft$fitIndices[,1], sft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")
 
# Choose the lowest power for which the scale free topology index reaches 0.90
```

# Construct a gene co-expression matrix and generate modules
# softPower threshold explained here: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

```{r}
# Build the adjacency "correlation" matrix

pe <- sft$powerEstimate
softPower = pe
adjc = adjacency(rlogtrt, 
                      power=softPower, 
                      type="signed")
#specify signed network type
 
# Topological overlap matrix (TOM) of the adjacency matrix
TOM = TOMsimilarity(adjc, TOMType="signed") # specify network type

# Calculate the corresponding dissimilarity
dissTOM = 1-TOM

```

# Detect modules

```{r}
# Hierarchical clustering of the genes based on TOM dissimilarity
geneTree = flashClust(as.dist(dissTOM), method="average")
plot(geneTree, xlab="", sub="", cex=0.3, 
     main= "Gene Clustering on TOM-based dissimilarity", 
     labels= FALSE, hang=0.04)

# Set minimum number of genes in a module
minModuleSize = 20

# Module identification using dynamic tree cut algorithm
dynamicMods = cutreeDynamic(dendro= geneTree, 
                            distM= dissTOM, deepSplit=2,
                            pamRespectsDendro= FALSE, 
                            minClusterSize = minModuleSize,
                            verbose = 2)
# Modules identified
table(dynamicMods)

# Assign module colours
dynamicColors= labels2colors(dynamicMods)

table(dynamicColors)

# Plot dendrogram of igengenes
plotDendroAndColors(geneTree, dynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')


# Discard unassigned genes, and focus on the rest
# This article discourages removal of grey genes:
# https://www.researchgate.net/post/Is_there_any_advantage_in_removing_unassigned_grey_genes_when_performing_a_weighted_co-expression_analysis_WGCNA_then_running_analysis_again
#restGenes = (dynamicColors != "grey")
# adjc1 = adjacency(rlogtrt[,restGenes], 
#                       power=softPower, 
#                       type="signed")
# 
# TOM1 <- TOMsimilarity(adjc1, TOMType="signed")
# 
# dissTOM1 = 1-TOM1
# 
# # Repeat module detection
# #colnames(dissTOM1) =rownames(diss1)
# colnames(dissTOM1) =rownames(dissTOM1) =rlogtrt[restGenes]
# 
# geneTree1 <- flashClust(as.dist(dissTOM1), method="average" )
# 
# plotDendroAndColors(geneTree1, 
#                     dynamicColors[restGenes], 
#                     "Dynamic Tree Cut", 
#                     dendroLabels = FALSE, 
#                     hang = 0.03, addGuide = TRUE, 
#                     guideHang = 0.05, 
#                     main = "Gene dendrogram and module colors")

# Set the diagonal of the dissimilarity to NA 
diag(dissTOM) = NA;

# Visualize the Tom plot. 
# Raise the dissimilarity matrix to the power of 4 to bring out the module structure
# sizeGrWindow(4,4)
# 
# TOMplot(dissTOM, geneTree, #intensive!
#         as.character(dynamicColors))

# Extract modules
module_colors= setdiff(unique(dynamicColors), "grey")
for (color in module_colors){
    module=rlogtrt[which(dynamicColors==color)]
    write.table(module, paste("module_",color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}

# Look at expression patterns of these genes as clustered
module.order <- unlist(tapply(1:ncol(rlogtrt),
                              as.factor(dynamicColors),I))

m<-t(t(rlogtrt[,module.order])/
       apply(rlogtrt[,module.order],2,max))

sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
heatmap(t(m),zlim=c(0,1),col=gray.colors(100),
        Rowv=NA,Colv=NA,labRow=NA,scale="none",
        RowSideColors=dynamicColors[module.order])

```

# Quantify module similarity by eigengene correlation. Eigengenes = Module representatives
# i.e. merge modules whose expression profiles are very similar

```{r}
# Calculate eigengenes
MEList = moduleEigengenes(rlogtrt, 
                         colors= dynamicColors,
                         softPower = softPower)
                         
MEs = MEList$eigengenes;

plotEigengeneNetworks(MEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))

# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);

# Cluster module eigengenes
METree = flashClust(as.dist(MEDiss), method= "average")

sizeGrWindow(7,6)
plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")

save(dynamicMods, MEList, MEs, MEDiss, METree, file= "../../processed/DESEQ/Network_modules_signed.RData")
```

# Merge at a selected threshold

```{r}
# Set threshold for merging modules 
# Can choose no merge i.e. MEDissThres=0.0)
# Merge modules that are 85% similar
MEDissThres = 0.15
abline(h=MEDissThres, col ="red")

# Call automatic merging function
merge = mergeCloseModules(rlogtrt, 
                          dynamicColors, 
                          cutHeight= MEDissThres, 
                          verbose =3)
mergedColors = merge$colors;
mergedMEs = merge$newMEs;


# Plot dendrogram with module colors below it
#pdf(file="../../plots/cluster.pdf")
plotDendroAndColors(geneTree, 
                    cbind(dynamicColors, mergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
#dev.off()


# Rename to moduleColors
moduleColors = mergedColors

# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;

save(MEs, moduleLabels, moduleColors, geneTree, 
     file= "../../processed/DESEQ/Network_modules_signed_merge.RData")

```

# Visualize weighted network after merge via heatmap

```{r}
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^18;

# Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;

# Call the plot function
pdf(file = "../../plots/weighted_heat.pdf", wi = 6, he = 6)
sizeGrWindow(6,6)
#TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")
dev.off()

# For 400 genes
nSelect = 400
# For reproducibility, we set the random seed
set.seed(10);
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

select = sample(nGenes, size = nSelect);
selectTOM = dissTOM[select, select];

# There’s no simple way to restrict tree to a subset of genes, so must re-cluster
selectTree = hclust(as.dist(selectTOM), method = "average")
selectColors = moduleColors[select];

pdf(file = "../../plots/weighted_heat.pdf", wi = 7, he = 7)
sizeGrWindow(7,7)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^20;
diag(plotDiss) = NA;
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap, 400 genes")
dev.off()
```

# Relate gene expression modules to diet treatment
# https://peterlangfelder.com/2018/11/25/working-with-categorical-variables/

```{r}
# Sample info
phenDat1 <- phenDat.sva[,6]

# rlog-transformed exprs data
rlogtrt <- read.table("../../processed/DESEQ/rlog.wg0.txt", 
                       sep = "\t",
                       stringsAsFactors = FALSE)

rlogtrt = as.data.frame(t(rlogtrt)) 
dim(rlogtrt) 

# Correlate traits 
# Define number of genes and samples
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

# Recalculate module eigengens
MEs = moduleEigengenes(rlogtrt, moduleColors)$eigengenes

# Isolate treatment from sample data
trt <- as.data.frame(phenDat.sva$trt_tis);
names(trt) = "treatment"

# Add the weight to existing module eigengenes
MET = orderMEs(cbind(MEs, trt))

# Plot the relationships among the eigengenes and the trait
sizeGrWindow(9,9);
par(cex = 0.9)
plotEigengeneNetworks(MET, "", marDendro = c(0,4,1,2), 
                      marHeatmap = c(3,4,1,2), 
                      cex.lab = 0.8, 
                      xLabelsAngle = 90)

```

# VST data

```{r}
VSTtrt = as.data.frame(t(vst.wg0)) 
dim(VSTtrt) 
outls = goodSamplesGenes(VSTtrt, verbose = 3)
outls$allOK 

# Cluster samples to check outliers
sampleTree.vst = hclust(dist(VSTtrt), method = "average");

sizeGrWindow(12,9) # inches
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree.vst, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

```

# Find modules

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
vsft = pickSoftThreshold(VSTtrt, powerVector=powers, 
                        corFnc = cor, # see FAQ point 3
                        networkType="signed",
                        verbose =5)
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(vsft$fitIndices[,1], 
     -sign(vsft$fitIndices[,3])*vsft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(vsft$fitIndices[,1], 
     -sign(vsft$fitIndices[,3])*vsft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

abline(h=0.90, col="red")

plot(vsft$fitIndices[,1], vsft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(vsft$fitIndices[,1], vsft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")

# Build the adjacency "correlation" matrix
pw <- vsft$powerEstimate
vsoftPower = pw
vadjc = adjacency(VSTtrt, 
                      power=softPower, 
                      type="signed")
 
# Topological overlap matrix (TOM) of the adjacency matrix
vTOM = TOMsimilarity(vadjc, TOMType="signed") # specify network type

# Calculate the corresponding dissimilarity
vdissTOM = 1-vTOM

# Hierarchical clustering of the genes based on TOM dissimilarity
vgeneTree = flashClust(as.dist(vdissTOM), method="average")
plot(vgeneTree, xlab="", sub="", cex=0.3, 
     main= "Gene Clustering on TOM-based dissimilarity", 
     labels= FALSE, hang=0.04)

# Set minimum number of genes in a module
minModuleSize = 20

# Module identification using dynamic tree cut algorithm
vdynamicMods = cutreeDynamic(dendro= vgeneTree, 
                            distM= vdissTOM, deepSplit=2,
                            pamRespectsDendro= FALSE, 
                            minClusterSize = minModuleSize,
                            verbose = 2)
# Modules identified
table(vdynamicMods)

# Assign module colours
vdynamicColors= labels2colors(vdynamicMods)

table(vdynamicColors)

# Plot dendrogram of igengenes
plotDendroAndColors(vgeneTree, vdynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')

# Set the diagonal of the dissimilarity to NA 
diag(vdissTOM) = NA;

# Extract modules
vmodule_colors= setdiff(unique(vdynamicColors), "grey")
for (color in vmodule_colors){
    vmodule=VSTtrt[which(vdynamicColors==color)]
    write.table(vmodule, paste("module_",color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}

# Look at expression patterns of these genes as clustered
vmodule.order <- unlist(tapply(1:ncol(VSTtrt),
                              as.factor(vdynamicColors),I))

vm<-t(t(VSTtrt[,vmodule.order])/
       apply(VSTtrt[,vmodule.order],2,max))

sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
heatmap(t(vm),zlim=c(0,1),col=gray.colors(100),
        Rowv=NA,Colv=NA,labRow=NA,scale="none",
        RowSideColors=vdynamicColors[vmodule.order])

# Calculate eigengenes
vMEList = moduleEigengenes(VSTtrt, 
                         colors= vdynamicColors,
                         softPower = pw)
                         
vMEs = vMEList$eigengenes;

plotEigengeneNetworks(vMEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))

# Calculate dissimilarity of module eigengenes
vMEDiss = 1-cor(vMEs);

# Cluster module eigengenes
vMETree = flashClust(as.dist(vMEDiss), method= "average")

sizeGrWindow(7,6)
plot(vMETree, main= "Clustering of module eigengenes", xlab= "", sub= "")

save(vdynamicMods, vMEList, vMEs, vMEDiss, vMETree, file= "../../processed/DESEQ/VST_modules_signed.RData")

# Merge similar modules
vMEDissThres = 0.15
abline(h=vMEDissThres, col ="red")

# Call automatic merging function
vmerge = mergeCloseModules(VSTtrt, 
                          vdynamicColors, 
                          cutHeight= vMEDissThres, 
                          verbose =3)
vmergedColors = vmerge$colors;
vmergedMEs = vmerge$newMEs;


# Plot dendrogram with module colors below it
#pdf(file="../../plots/cluster.pdf")
plotDendroAndColors(vgeneTree, 
                    cbind(vdynamicColors, vmergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
#dev.off()


# Rename to moduleColors
vmoduleColors = vmergedColors

# Construct numerical labels corresponding to the colors
vcolorOrder = c("grey", standardColors(50));
vmoduleLabels = match(vmoduleColors, vcolorOrder)-1;
vMEs = vmergedMEs;

save(vMEs, vmoduleLabels, vmoduleColors, vgeneTree, 
     file= "../../processed/DESEQ/VST_modules_signed_merge.RData")

```

# Relate modules to diet

```{r}
# Sample info
phenDat1 <- phenDat.sva[,6]

# rlog-transformed exprs data
VSTtrt <- read.table("../../processed/DESEQ/vst.wg0.txt", 
                       sep = "\t",
                       stringsAsFactors = FALSE)

VSTtrt = as.data.frame(t(VSTtrt)) 
dim(VSTtrt) 

# Correlate traits 
# Define number of genes and samples
vGenes = ncol(VSTtrt)
vSamples = nrow(VSTtrt)

# Recalculate module eigengens
vMEs = moduleEigengenes(VSTtrt, vmoduleColors)$eigengenes

# Isolate treatment from sample data
vtrt <- as.data.frame(phenDat.sva$trt_tis);
names(vtrt) = "treatment"

# Add the weight to existing module eigengenes
vMET = orderMEs(cbind(vMEs, vtrt))

# Plot the relationships among the eigengenes and the trait
sizeGrWindow(9,9);
par(cex = 0.9)
plotEigengeneNetworks(vMET, "", marDendro = c(0,4,1,2), 
                      marHeatmap = c(3,4,1,2), 
                      cex.lab = 0.8, 
                      xLabelsAngle = 90)

```
