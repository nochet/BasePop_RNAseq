---
title: "WGCNA clustering"
author: "Enoch Ng'oma"
date: "2/5/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Tutorials
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# https://wikis.utexas.edu/display/bioiteam/Clustering+using+WGCNA
# https://bioconductor.org/packages/release/bioc/vignettes/CVE/inst/doc/WGCNA_from_TCGA_RNAseq.html

library(flashClust)
library(WGCNA)
library(ape)

options(stringsAsFactors = FALSE)
allowWGCNAThreads()
#disableWGCNAThreads()

library(DESeq2)
library(limma)
library(tidyverse)
library(cowplot)
library(AnnotationDbi)

set.seed(341072)
```

# Expression Data

```{r}
countdata <- read.csv("../../processed/DESEQ/Expr_countData.csv")
rownames(countdata) <- countdata[,1]
countdata[,1] <- NULL
countdata <- as.matrix(countdata)

```

# Prep sample data for WGCNA

```{r}
# Sample info
phenDat.sva <- read.csv("../../processed/DESEQ/sampleDat_with_SV.csv")
rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL
phenDat.sva$batch <- as.factor(phenDat.sva$batch)
phenDat.sva$treat_tissue <- paste(phenDat.sva$treatment,"_",phenDat.sva$tissue, sep="")

# Sample data to numerical format
phenDat.sva$trt_tis <- ifelse(phenDat.sva$treat_tissue == "C_B",1, 
                          ifelse(phenDat.sva$treat_tissue=="C_H",2,
                          ifelse(phenDat.sva$treat_tissue=="C_O",3,
                          ifelse(phenDat.sva$treat_tissue=="DR_B",4,
                          ifelse(phenDat.sva$treat_tissue=="DR_H",5,
                          ifelse(phenDat.sva$treat_tissue=="DR_O",6,
                          ifelse(phenDat.sva$treat_tissue=="HS_B",7,
                          ifelse(phenDat.sva$treat_tissue=="HS_H",8, 9))))))))

phenDat.sva$trtm <- ifelse(phenDat.sva$treatment == "C",1, 
                          ifelse(phenDat.sva$treatment=="DR",2,3))

phenDat.sva$tiss <- ifelse(phenDat.sva$tissue == "B",1, 
                          ifelse(phenDat.sva$tissue=="H",2,3))  

trt <- phenDat.sva[,6:8]
names(trt) = c("Diet-Tissue","Diet","Tissue")

```

# DESeq object

```{r}
# dd0 <- DESeqDataSetFromMatrix(countData = countdata,
#                               colData = phenDat.sva,
#                               design = ~ SV1 + batch)
# 
# dd0.wg <- estimateSizeFactors(dd0)
# nc <- counts(dd0.wg, normalized=TRUE)
# filter <- rowSums(nc >= 10) >= 2
# 
# # log transform null DESeq model: design ~ SV1 + batch
# rlog.wg0 <- rlog(dd0.wg[filter,], blind = FALSE, fitType = "parametric")
# vst.wg0 <- varianceStabilizingTransformation(dd0.wg[filter,], 
#                                              blind = FALSE, fitType = "parametric")

# rlog transformation of full model
# load("../../processed/DESEQ/dds_deseq01.Rda")
# 
# rlog.wg1 <- rlog(dds_deseq.01, blind = FALSE, fitType = "parametric")
# write.table(assay(rlog.wg1),
#             file="../../processed/DESEQ/rlog.wg1.txt",
#             sep="\t")

# log transform full DESeq model: design ~ SV1 + batch + tissue + treatment
# rlog.wg1 <- rlog(rlog.wg1, blind = FALSE, fitType = "parametric")

# save for comparison
# write.table(assay(vst.w),
#             file="../../processed/DESEQ/vst.w.txt",
#             sep="\t")
# write.table(vst.wg0,
#             file="../../processed/DESEQ/vst.wg0.txt",
#             sep="\t")

rlog.wg0 <- read.table("../../processed/DESEQ/rlog.wg0.txt",
            sep="\t", stringsAsFactors = FALSE)
vst.wg0 <- read.table("../../processed/DESEQ/vst.wg0.txt",
            sep="\t", stringsAsFactors = FALSE)
rlog.wg1 <- read.table("../../processed/DESEQ/rlog.wg1.txt", 
            sep="\t", stringsAsFactors = FALSE)

rlog.wg1[1:2,1:4]
rlog.wg0[1:2,1:4]
vst.wg0[1:2,1:4]

boxplot(rlog.wg0)
boxplot(vst.wg0)
```

# WGCNA Preliminaries

```{r}
# Get data into WGCNA format - genes as columns, samples as rows
rlogtrt = as.data.frame(t(rlog.wg0)) 
dim(rlogtrt) 

# Check gene outliers or too many missing values
outls = goodSamplesGenes(rlogtrt, verbose = 3)
outls$allOK 

# Cluster samples to check outliers
sampleTree = hclust(dist(rlogtrt), method = "average");

sizeGrWindow(12,9) # inches
par(cex = 0.6);
par(mar = c(0,4,2,0))

plot(sampleTree, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

# Visualize how traits relate to sample dendrogram
# (white = low, red = high, grey = missing)
traitColors = numbers2colors(trt, signed = FALSE);

# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree, traitColors,
                  groupLabels = names(trt),
                  main = "Sample dendrogram and trait heatmap")
```

# Select soft power

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
sft = pickSoftThreshold(rlogtrt, powerVector=powers, 
                        corFnc = cor, # see FAQ point 3
                        networkType="signed",
                        verbose =5)
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9

# Scale-free topology fit index as a function of the sft power
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

# line corresponding to R^2 cut-off of h
abline(h=0.90, col="red")

# Mean connectivity as a function of the sft power
plot(sft$fitIndices[,1], sft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")
 
# Choose the lowest power for which the scale free topology index reaches 0.90
```

# Construct a gene co-expression matrix and generate modules
# softPower threshold explained here: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

```{r}
# Build the adjacency "correlation" matrix

pe <- sft$powerEstimate
softPower = pe
adjc = adjacency(rlogtrt, 
                      power=softPower, 
                      type="signed")
#specify signed network type
 
# Topological overlap matrix (TOM) of the adjacency matrix
TOM = TOMsimilarity(adjc, TOMType="signed") # specify network type

# Calculate the corresponding dissimilarity
dissTOM = 1-TOM

# Note: dissTOM calc minimizes effects of noise and spurious associations
```

# Detect modules

```{r}
# Hierarchical clustering of the genes based on TOM dissimilarity
geneTree = flashClust(as.dist(dissTOM), method="average")

sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", cex=0.3, 
     main= "Gene Clustering on TOM-based dissimilarity", 
     labels= FALSE, hang=0.04)

# Set minimum number of genes in a module
minModuleSize = 10

# Module identification using dynamic tree cut algorithm
dynamicMods = cutreeDynamic(dendro= geneTree, 
                            distM= dissTOM, deepSplit=2,
                            pamRespectsDendro= FALSE, 
                            minClusterSize = minModuleSize,
                            verbose = 2)
# Modules identified
table(dynamicMods)

# Assign module colours
dynamicColors= labels2colors(dynamicMods)

table(dynamicColors)

# MDS plot
cmd1 <- cmdscale(as.dist(dissTOM), k=2)
sizeGrWindow(7, 6)
pdf(file="../../plots/MDSplot_rlog_trt.pdf")
par(mfrow=c(1,1))
plot(cmd1, col=as.character(dynamicColors), main="MDS plot, rlog",
xlab="Scaling Dimension 1", ylab="Scaling Dimension 2")
dev.off()

# Plot dendrogram of igengenes
plotDendroAndColors(geneTree, dynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')


# Discard unassigned genes, and focus on the rest
# This article discourages removal of grey genes:
# https://www.researchgate.net/post/Is_there_any_advantage_in_removing_unassigned_grey_genes_when_performing_a_weighted_co-expression_analysis_WGCNA_then_running_analysis_again
#restGenes = (dynamicColors != "grey")
# adjc1 = adjacency(rlogtrt[,restGenes], 
#                       power=softPower, 
#                       type="signed")
# 
# TOM1 <- TOMsimilarity(adjc1, TOMType="signed")
# 
# dissTOM1 = 1-TOM1
# 
# # Repeat module detection
# #colnames(dissTOM1) =rownames(diss1)
# colnames(dissTOM1) =rownames(dissTOM1) =rlogtrt[restGenes]
# 
# geneTree1 <- flashClust(as.dist(dissTOM1), method="average" )
# 
# plotDendroAndColors(geneTree1, 
#                     dynamicColors[restGenes], 
#                     "Dynamic Tree Cut", 
#                     dendroLabels = FALSE, 
#                     hang = 0.03, addGuide = TRUE, 
#                     guideHang = 0.05, 
#                     main = "Gene dendrogram and module colors")

# Set the diagonal of the dissimilarity to NA 
diag(dissTOM) = NA;

# Visualize the Tom plot. 
# Raise the dissimilarity matrix to the power of 4 to bring out the module structure
# sizeGrWindow(4,4)
# 
# TOMplot(dissTOM, geneTree, #intensive!
#         as.character(dynamicColors))

```

# Quantify module similarity by eigengene correlation

```{r}
# Calculate eigengenes
MEList = moduleEigengenes(rlogtrt, 
                         colors= dynamicColors,
                         softPower = softPower)
                         
MEs = MEList$eigengenes;

plotEigengeneNetworks(MEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))

# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);

# Cluster module eigengenes
METree = flashClust(as.dist(MEDiss), method= "average")

sizeGrWindow(7,6)
plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")

save(dynamicMods, MEList, MEs, MEDiss, METree, file= "../../processed/DESEQ/Network_modules_signed.RData")
```

# Merge at a selected threshold

```{r}
# Set threshold for merging modules 
# Can choose no merge i.e. MEDissThres=0.0)
# Merge modules that are 85% similar
MEDissThres = 0.15
abline(h=MEDissThres, col ="red")

# Call automatic merging function
merge = mergeCloseModules(rlogtrt, 
                          dynamicColors, 
                          cutHeight= MEDissThres, 
                          verbose =3)
mergedColors = merge$colors;
mergedMEs = merge$newMEs;


# Plot dendrogram with module colors below it
#pdf(file="../../plots/cluster.pdf")
plotDendroAndColors(geneTree, 
                    cbind(dynamicColors, mergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
#dev.off()

cmd1 <- cmdscale(as.dist(dissTOM), k=4)

par(mfrow=c(2,3))
plot(cmd1[,c(1,2)],col= as.character(dynamicColors))
plot(cmd1[,c(1,3)],col= as.character(dynamicColors)) 
plot(cmd1[,c(1,4)],col= as.character(dynamicColors)) 
plot(cmd1[,c(2,3)],col= as.character(dynamicColors)) 
plot(cmd1[,c(2,4)],col= as.character(dynamicColors)) 
plot(cmd1[,c(3,4)],col= as.character(dynamicColors))

# Select one to save
#pdf(file="../../plots/MDSplot_rlog_trt_merged.pdf")
par(mfrow=c(1,1))
plot(cmd1, col=as.character(mergedColors), main="MDS plot, rlog",
xlab="Scaling Dimension 1", ylab="Scaling Dimension 2")
#dev.off()

library(scatterplot3d)
par(mfrow=c(1,1))
scatterplot3d(cmd1[,1:3], 
              color=as.character(dynamicColors), 
              main="MDS plot",
              xlab="Scaling Dimension 1", 
              ylab="Scaling Dimension 2", 
              zlab="Scaling Dimension 3",
              cex.axis=1.5,angle=320)

# Rename to moduleColors
moduleColors = mergedColors

# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;

save(MEs, moduleLabels, moduleColors, geneTree, 
     file= "../../processed/DESEQ/Network_modules_signed_merge.RData")

```

# Visualize weighted network after merge via heatmap

```{r}
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^18;

# Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;

# Call the plot function
pdf(file = "../../plots/weighted_heat.pdf", wi = 6, he = 6)
sizeGrWindow(6,6)
#TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")
dev.off()

# For 400 genes
nSelect = 400
# For reproducibility, we set the random seed
set.seed(10);
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

select = sample(nGenes, size = nSelect);
selectTOM = dissTOM[select, select];

# Thereâ€™s no simple way to restrict tree to a subset of genes, so must re-cluster
selectTree = hclust(as.dist(selectTOM), method = "average")
selectColors = moduleColors[select];

pdf(file = "../../plots/weighted_heat.pdf", wi = 7, he = 7)
sizeGrWindow(7,7)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^20;
diag(plotDiss) = NA;
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap, 400 genes")
dev.off()
```

# Relate gene expression modules to diet treatment
# https://peterlangfelder.com/2018/11/25/working-with-categorical-variables/

```{r}
# rlog-transformed exprs data
rlogtrt <- read.table("../../processed/DESEQ/rlog.wg0.txt", 
                       sep = "\t",
                       stringsAsFactors = FALSE)

rlogtrt = as.data.frame(t(rlogtrt)) 
dim(rlogtrt) 

# Correlate traits 

# Define number of genes and samples
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

# Recalculate module eigengens (use non-merged)
# MEs0 = moduleEigengenes(rlogtrt, dynamicColors)$eigengenes
# MEs = orderMEs(MEs0)

# Quantify module-trait association
moduleTraitCor = cor(MEs, trt, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

# Add the weight to existing module eigengenes
MET = orderMEs(cbind(MEs, trt))

# Plot the relationships among the eigengenes and the trait
sizeGrWindow(9,9);
par(cex = 0.9)
plotEigengeneNetworks(MET, "", marDendro = c(0,4,1,2), 
                      marHeatmap = c(3,4,1,2), 
                      cex.lab = 0.8, 
                      xLabelsAngle = 90)

sizeGrWindow(10,6)

# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                        signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(5, 1, 1, 5)+ 0.1) ;
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
             xLabels = names(trt),
             yLabels = names(MEs),
             ySymbols = names(MEs),
             colorLabels = FALSE,
             colors = blueWhiteRed(50),
             textMatrix = textMatrix,
             setStdMargins = FALSE,
             cex.text = 0.5,
             zlim = c(-1,1),
             main = paste("Module-trait relationships"))

# Gene significance and module membership
# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(rlogtrt, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(
  as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(rlogtrt, trt, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(
  as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(trt), sep="");
names(GSPvalue) = paste("p.GS.", names(trt), sep="");

# Intramodular analysis - 
# identify genes with high gene significance (GS) and module membership (MM)

module = "greenyellow"
column = match(module, modNames);
moduleGenes = dynamicColors==module;

sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes1, column1]),
                   abs(geneTraitSignificance[moduleGenes1, 1]),
                   xlab = paste("Module Membership in", module1, "module"),
                   ylab = "GS",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, 
                   col = module1)

names(rlogtrt)[dynamicColors=="greenyellow"]

module1 = "cyan"
column1 = match(module1, modNames);
moduleGenes1 = dynamicColors==module1

names(rlogtrt)[moduleColors=="lightcyan"]
```

# VST data

```{r}
VSTtrt = as.data.frame(t(vst.wg0)) 
dim(VSTtrt) 
outls = goodSamplesGenes(VSTtrt, verbose = 3)
outls$allOK 

# Cluster samples to check outliers
sampleTree.vst = hclust(dist(VSTtrt), method = "average");

sizeGrWindow(12,9) # inches
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree.vst, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

```

# Find modules

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
vsft = pickSoftThreshold(VSTtrt, powerVector=powers, 
                        corFnc = cor, # see FAQ point 3
                        networkType="signed",
                        verbose =5)
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(vsft$fitIndices[,1], 
     -sign(vsft$fitIndices[,3])*vsft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(vsft$fitIndices[,1], 
     -sign(vsft$fitIndices[,3])*vsft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

abline(h=0.90, col="red")

plot(vsft$fitIndices[,1], vsft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(vsft$fitIndices[,1], vsft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")

# Build the adjacency "correlation" matrix
pw <- vsft$powerEstimate
vsoftPower = pw
vadjc = adjacency(VSTtrt, 
                      power=softPower, 
                      type="signed")
 
# Topological overlap matrix (TOM) of the adjacency matrix
vTOM = TOMsimilarity(vadjc, TOMType="signed") # specify network type

# Calculate the corresponding dissimilarity
vdissTOM = 1-vTOM

# Hierarchical clustering of the genes based on TOM dissimilarity
vgeneTree = flashClust(as.dist(vdissTOM), method="average")
plot(vgeneTree, xlab="", sub="", cex=0.3, 
     main= "Gene Clustering on TOM-based dissimilarity", 
     labels= FALSE, hang=0.04)

# Set minimum number of genes in a module
minModuleSize = 20

# Module identification using dynamic tree cut algorithm
vdynamicMods = cutreeDynamic(dendro= vgeneTree, 
                            distM= vdissTOM, deepSplit=2,
                            pamRespectsDendro= FALSE, 
                            minClusterSize = minModuleSize,
                            verbose = 2)
# Modules identified
table(vdynamicMods)

# Assign module colours
vdynamicColors= labels2colors(vdynamicMods)

table(vdynamicColors)

# Plot dendrogram of igengenes
plotDendroAndColors(vgeneTree, vdynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')

# Set the diagonal of the dissimilarity to NA 
diag(vdissTOM) = NA;

# Extract modules
vmodule_colors= setdiff(unique(vdynamicColors), "grey")
for (color in vmodule_colors){
    vmodule=VSTtrt[which(vdynamicColors==color)]
    write.table(vmodule, paste("module_",color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}

# Look at expression patterns of these genes as clustered
vmodule.order <- unlist(tapply(1:ncol(VSTtrt),
                              as.factor(vdynamicColors),I))

vm<-t(t(VSTtrt[,vmodule.order])/
       apply(VSTtrt[,vmodule.order],2,max))

sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
heatmap(t(vm),zlim=c(0,1),col=gray.colors(100),
        Rowv=NA,Colv=NA,labRow=NA,scale="none",
        RowSideColors=vdynamicColors[vmodule.order])

# Calculate eigengenes
vMEList = moduleEigengenes(VSTtrt, 
                         colors= vdynamicColors,
                         softPower = pw)
                         
vMEs = vMEList$eigengenes;

plotEigengeneNetworks(vMEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))

# Calculate dissimilarity of module eigengenes
vMEDiss = 1-cor(vMEs);

# Cluster module eigengenes
vMETree = flashClust(as.dist(vMEDiss), method= "average")

sizeGrWindow(7,6)
plot(vMETree, main= "Clustering of module eigengenes", xlab= "", sub= "")

save(vdynamicMods, vMEList, vMEs, vMEDiss, vMETree, file= "../../processed/DESEQ/VST_modules_signed.RData")

# Merge similar modules
vMEDissThres = 0.15
abline(h=vMEDissThres, col ="red")

# Call automatic merging function
vmerge = mergeCloseModules(VSTtrt, 
                          vdynamicColors, 
                          cutHeight= vMEDissThres, 
                          verbose =3)
vmergedColors = vmerge$colors;
vmergedMEs = vmerge$newMEs;


# Plot dendrogram with module colors below it
#pdf(file="../../plots/cluster.pdf")
plotDendroAndColors(vgeneTree, 
                    cbind(vdynamicColors, vmergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
#dev.off()


# Rename to moduleColors
vmoduleColors = vmergedColors

# Construct numerical labels corresponding to the colors
vcolorOrder = c("grey", standardColors(50));
vmoduleLabels = match(vmoduleColors, vcolorOrder)-1;
vMEs = vmergedMEs;

save(vMEs, vmoduleLabels, vmoduleColors, vgeneTree, 
     file= "../../processed/DESEQ/VST_modules_signed_merge.RData")

```

# Relate modules to diet

```{r}
# Sample info
phenDat1 <- phenDat.sva[,6]

# rlog-transformed exprs data
VSTtrt <- read.table("../../processed/DESEQ/vst.wg0.txt", 
                       sep = "\t",
                       stringsAsFactors = FALSE)

VSTtrt = as.data.frame(t(VSTtrt)) 
dim(VSTtrt) 

# Correlate traits 
# Define number of genes and samples
vGenes = ncol(VSTtrt)
vSamples = nrow(VSTtrt)

# Recalculate module eigengens
vMEs = moduleEigengenes(VSTtrt, vmoduleColors)$eigengenes

# Isolate treatment from sample data
vtrt <- as.data.frame(phenDat.sva$trt_tis);
names(vtrt) = "treatment"

# Add the weight to existing module eigengenes
vMET = orderMEs(cbind(vMEs, vtrt))

# Plot the relationships among the eigengenes and the trait
sizeGrWindow(9,9);
par(cex = 0.9)
plotEigengeneNetworks(vMET, "", marDendro = c(0,4,1,2), 
                      marHeatmap = c(3,4,1,2), 
                      cex.lab = 0.8, 
                      xLabelsAngle = 90)

```
