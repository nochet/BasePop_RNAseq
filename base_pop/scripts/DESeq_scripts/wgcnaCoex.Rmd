---
title: "WGCNA clustering"
author: "Enoch Ng'oma"
date: "2/5/2019"
output: 
  html_document:
    toc: true
    toc_depth: 2 #defaults to 3 if not specified
    toc_float: true
    number_sections: true
    fig_width: 7
    fig_height: 6
    fig_caption: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Tutorials
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# https://wikis.utexas.edu/display/bioiteam/Clustering+using+WGCNA
# https://bioconductor.org/packages/release/bioc/vignettes/CVE/inst/doc/WGCNA_from_TCGA_RNAseq.html

library(flashClust)
library(WGCNA)
library(ape)

options(stringsAsFactors = FALSE)
allowWGCNAThreads()
#disableWGCNAThreads()

library(DESeq2)
library(limma)
library(tidyverse)
library(cowplot)
library(AnnotationDbi)
library(org.Dm.eg.db)

set.seed(341072)
```

# Expression Data

```{r}
# countdata <- read.csv("../../processed/DESEQ/Expr_countData.csv")
# rownames(countdata) <- countdata[,1]
# countdata[,1] <- NULL
# countdata <- as.matrix(countdata)

```

# Prep sample data for WGCNA

```{r}
# Sample info
phenDat.sva <- read.csv("../../processed/DESEQ/sampleDat_with_SV.csv")
rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL
phenDat.sva$batch <- as.factor(phenDat.sva$batch)
phenDat.sva$treat_tissue <- paste(phenDat.sva$treatment,"_",phenDat.sva$tissue, sep="")

# Sample data to numerical format
phenDat.sva$trt_tis <- ifelse(phenDat.sva$treat_tissue == "C_B",1, 
                          ifelse(phenDat.sva$treat_tissue=="C_H",2,
                          ifelse(phenDat.sva$treat_tissue=="C_O",3,
                          ifelse(phenDat.sva$treat_tissue=="DR_B",4,
                          ifelse(phenDat.sva$treat_tissue=="DR_H",5,
                          ifelse(phenDat.sva$treat_tissue=="DR_O",6,
                          ifelse(phenDat.sva$treat_tissue=="HS_B",7,
                          ifelse(phenDat.sva$treat_tissue=="HS_H",8, 9))))))))

# phenDat.sva$trtm <- ifelse(phenDat.sva$treatment == "C",1, 
#                           ifelse(phenDat.sva$treatment=="DR",2,3))
# 
# phenDat.sva$tiss <- ifelse(phenDat.sva$tissue == "B",1, 
#                           ifelse(phenDat.sva$tissue=="H",2,3))  

#trt <- phenDat.sva[,6:8]
#names(trt) = c("Diet-Tissue","Diet","Tissue")

trt <- phenDat.sva[,"treat_tissue"]

# Indicators for pairwise treatment contrasts
trt_prw <- binarizeCategoricalVariable(trt, 
                                       includePairwise = TRUE,
                                       includeLevelVsAll = TRUE,
                                       dropUninformative = TRUE)
trt_prw <- data.frame(trt, trt_prw)
trt_prw <- trt_prw[,2:37]


# Indicators for each level vs all others
trt_all <- binarizeCategoricalVariable(trt, 
                                       includePairwise = FALSE,
                                       includeLevelVsAll = TRUE)
trt_all <- data.frame(trt, trt_all)

```

# DESeq object

```{r}
# dd0 <- DESeqDataSetFromMatrix(countData = countdata,
#                               colData = phenDat.sva,
#                               design = ~ SV1 + batch)
# 
# dd0.wg <- estimateSizeFactors(dd0)
# nc <- counts(dd0.wg, normalized=TRUE)
# filter <- rowSums(nc >= 10) >= 2
# 
# # log transform null DESeq model: design ~ SV1 + batch
# rlog.wg0 <- rlog(dd0.wg[filter,], blind = FALSE, fitType = "parametric")
# vst.wg0 <- varianceStabilizingTransformation(dd0.wg[filter,], 
#                                              blind = FALSE, fitType = "parametric")

# rlog transformation of full model
# load("../../processed/DESEQ/dds_deseq01.Rda")
# 
# rlog.wg1 <- rlog(dds_deseq.01, blind = FALSE, fitType = "parametric")
# write.table(assay(rlog.wg1),
#             file="../../processed/DESEQ/rlog.wg1.txt",
#             sep="\t")

# log transform full DESeq model: design ~ SV1 + batch + tissue + treatment
# rlog.wg1 <- rlog(rlog.wg1, blind = FALSE, fitType = "parametric")

# save for comparison
# write.table(assay(vst.w),
#             file="../../processed/DESEQ/vst.w.txt",
#             sep="\t")
# write.table(vst.wg0,
#             file="../../processed/DESEQ/vst.wg0.txt",
#             sep="\t")

rlog.wg0 <- read.table("../../processed/DESEQ/Coexpression/rlog.wg0.txt",
            sep="\t", stringsAsFactors = FALSE)
vst.wg0 <- read.table("../../processed/DESEQ/Coexpression/vst.wg0.txt",
            sep="\t", stringsAsFactors = FALSE)
rlog.wg1 <- read.table("../../processed/DESEQ/Coexpression/rlog.wg1.txt", 
            sep="\t", stringsAsFactors = FALSE)

# Compare different transformtions
rlog.wg1[1:2,1:4]
rlog.wg0[1:2,1:4]
vst.wg0[1:2,1:4]

boxplot(rlog.wg0)
boxplot(vst.wg0)
```

# WGCNA Preliminaries

```{r}
# Get data into WGCNA format - genes as columns, samples as rows
rlogtrt = as.data.frame(t(rlog.wg0)) 
dim(rlogtrt) 

# Check gene outliers or too many missing values
outls = goodSamplesGenes(rlogtrt, verbose = 3)
outls$allOK 

# Cluster samples to check outliers
sampleTree = hclust(dist(rlogtrt), method = "average");

sizeGrWindow(12,9) # inches
par(mfrow=c(2,1))
plot(sampleTree, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", 
     cex.axis = 0.6)

# Visualize how traits relate to sample dendrogram
# (white = low, red = high, grey = missing)
#traitColors = numbers2colors(trt_prw, signed = FALSE);

traitColors = numbers2colors(trt_prw, signed = FALSE)

# Plot the sample dendrogram and the colors underneath
pdf(file="../../plots/sample_clustering.pdf")
#par(mfrow=c(2,1))
#par(mar = c(1,4,2,1))
#par(cex.lab=1.5, cex.axis=1.5, cex.main=1.5, cex.sub=1.5)
#par(cex = 1.5)
plotDendroAndColors(sampleTree, traitColors,
                   groupLabels = names(trt_prw),
                   main = "Sample dendrogram and diet heatmap",
                   cex.colorLabels = 0.6,
                   cex.dendroLabels = 0.6,
                   cex.rowText = 0.2)
dev.off()

#save(rlogtrt, trt_prw, file ="../../processed/DESEQ/Coexpression/trt-01-dataInput.RData")
load("../../processed/DESEQ/Coexpression/trt-01-dataInput.RData")
```

# Select soft power

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from = 10, to = 30, by=1)) 
sft = pickSoftThreshold(rlogtrt, powerVector=powers, 
                        #corFnc = cor, # see FAQ point 3
                        networkType="signed",
                        verbose = 5)
  
sizeGrWindow(9,5)
pdf(file="../../plots/softThreshold.pdf")
par(mfrow= c(1,2)) # one row, two columns panel
cex1=0.9

# Scale-free topology fit index as a function of the sft power
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

# line corresponding to R^2 cut-off of h
abline(h=0.90, col="red")

# Mean connectivity as a function of the sft power
plot(sft$fitIndices[,1], sft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")
dev.off()
# Choose the lowest power for which the scale free topology index reaches 0.90
```

# Construct a gene co-expression matrix and generate modules
# softPower threshold explained here: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

```{r}
# Build the adjacency "correlation" matrix
pe <- sft$powerEstimate
adjc = adjacency(rlogtrt, power=pe, type="signed")

# Topological overlap matrix (TOM) of the adjacency matrix
TOM = TOMsimilarity(adjc, TOMType="signed") # specify network type

# Calculate the corresponding dissimilarity
dissTOM = 1-TOM

#save(sft, adjc, TOM, dissTOM, file= "../../processed/DESEQ/Coexpression/adjc_TOM.RData")
load("../../processed/DESEQ/Coexpression/adjc_TOM.RData")

# Note: dissTOM calc minimizes effects of noise and spurious associations
```

# Detect modules

```{r}
# Hierarchical clustering of the genes based on TOM dissimilarity
geneTree = flashClust(as.dist(dissTOM), method = "average")

sizeGrWindow(12,9)
plot(geneTree, xlab = "", sub = "", cex = 0.3, 
     main = "Gene Clustering on TOM-based dissimilarity", 
     labels = FALSE, hang = 0.04)

# Set minimum number of genes in a module
minModuleSize = 20

# Module identification using dynamic tree cut algorithm
dynamicMods = cutreeDynamic(dendro = geneTree,
                            distM = dissTOM, 
                            deepSplit = 2,
                            pamRespectsDendro = FALSE, 
                            minClusterSize = minModuleSize)
                            
# Modules identified
table(dynamicMods)

# Assign module colours
dynamicColors= labels2colors(dynamicMods)

table(dynamicColors)

# Plot dendrogram of igengenes
plotDendroAndColors(geneTree, dynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')

# Set the diagonal of the dissimilarity to NA 
diag(dissTOM) = NA;

```

# Quantify module similarity by eigengene correlation

```{r}
# Calculate eigengenes
MEList = moduleEigengenes(rlogtrt, 
                         colors= dynamicColors,
                         softPower = pe)
                         
MEs = MEList$eigengenes;
#MET <- order(cbind(MEs, trt_prw$DR_H.Vs.C_B))

plotEigengeneNetworks(MEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))


# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);

# Cluster module eigengenes
METree = flashClust(as.dist(MEDiss), method= "average")

sizeGrWindow(7,6)
plot(MEs, main= "Clustering of module eigengenes", xlab= "", sub= "")

datME=moduleEigengenes(rlogtrt,moduleColors)$eigengenes
signif(cor(datME, use="p"), 2)

pdf(file="../../plots/pairwise_eigengene_plots.pdf", width = 9, height = 6)
par(mfrow=c(1,1))
par(cex = 0.6)
mar=c(1,1)
plotMEpairs(datME)
dev.off()

# See detected modules and their sizes
cat("\n\nNetwork Modules\n")
moduleColors = dynamicColors
module.table <- as.data.frame(table(moduleColors))
module.table <- module.table[match(gsub("ME", "", names(MEs)), module.table[,1]),] # same order of eigengenes as in MEs (needed for heatmap labels) 
print(module.table)
write.table(module.table, "../../processed/DESEQ/Coexpression/dynamicModules_Sizes.txt", quote=F, row.names=F, sep="\t")

```

# Merge at a selected threshold

```{r}
# Set threshold for merging modules 
# Can choose no merge i.e. MEDissThres=0.0)
# Merge modules that are 85% similar
MEDissThres = 0.10 # 0.05 is identical Dynamic Tree Cut
abline(h=MEDissThres, col ="red")

# Call automatic merging function
merge = mergeCloseModules(rlogtrt, 
                          dynamicColors, 
                          cutHeight= MEDissThres, 
                          verbose =3)

mergedColors = merge$colors;
mergedMEs = merge$newMEs;

table(mergedColors)

# Plot dendrogram with module colors below it
pdf(file="../../plots/dynamic_merged_clusters.pdf", width = 5, height = 3)
par(mfrow=c(2,2))
par(cex = 0.6)
plotDendroAndColors(geneTree, 
                    cbind(dynamicColors, mergedColors), 
                    c("Dynamic colors", "Module colors"),
                    main = NULL,
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
dev.off()

# Rename to moduleColors
table(moduleColors)

# See merged modules and their sizes
cat("\n\nNetwork Modules\n")
moduleColors = mergedColors
module.table_merged <- as.data.frame(table(moduleColors))
module.table_merged <- module.table_merged[match(gsub("ME", "", names(MEs)), module.table[,1]),] # same order of eigengenes as in MEs (needed for heatmap labels) 
print(module.table_merged)
write.table(module.table_merged, "../../processed/DESEQ/Coexpression/mergedModules_Sizes.txt", quote=F, row.names=F, sep="\t")

MEcount <- length(colnames(MEs))
rownames(MEs) <- rownames(trt_prw)
write.table(MEs, "../../processed/DESEQ/Coexpression/mergedModuleEigengenes_colorLabel.txt", row.names=F, quote=F, sep="\t")
modNames = substring(names(MEs), 3)  # remove "ME" at the beginning of module eigengene names
  
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;

# save(MEs, moduleLabels, moduleColors, geneTree, 
#       file= "../../processed/DESEQ/Network_modules_signed_merge.RData")
load("../../processed/DESEQ/Network_modules_signed_merge.RData")

module.table_merged <- module.table_merged[1:20,1:2]
#modTab <- module.table_merged %>% rename(Freq, genes)

```

# Relate gene expression modules to diet treatment
# https://peterlangfelder.com/2018/11/25/working-with-categorical-variables/

```{r}
# Define number of genes and samples
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

# Recalculate module eigengens (use non-merged)
MEs0 = moduleEigengenes(rlogtrt, moduleColors)$eigengenes
MEs = orderMEs(MEs0)

# Quantify module-trait association
moduleTraitCor = cor(MEs, trt_prw, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
#moduleTraitPvalueFish <- corPvalueFisher(moduleTraitCor, nSamples)

sizeGrWindow(8,6)

pdf(file = "../../plots/module-trait_correlations.pdf", wi = 7, he = 5)
par(mar=c(5.1,4.1,4.1,2.1))
#par(mfrow=c(1.5,1.2))
#par(mar = c(0,4,2,0))
par(cex = 0.55)
#sizeGrWindow(12,9)

# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                        signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
#par(mar = c(5, 1, 1, 5)+ 0.1) ;

# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
             xLabels = names(trt_prw),
             yLabels = names(MEs),
             ySymbols = names(MEs),
             colorLabels = TRUE,
             colors = blueWhiteRed(50),
             textMatrix = textMatrix,
             setStdMargins = FALSE,
             cex.text = 0.55,
             cex.lab = 0.8,
             zlim = c(-1,1),
             main = paste("Module-diet relationships"))
dev.off()
```

# Calculate the module membership values 
# aka. module eigengene based connectivity kME

```{r}
# names (colors) of the modules
modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(rlogtrt, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(
  as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");

geneTraitSignificance = as.data.frame(cor(rlogtrt, trt_prw, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(
  as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(trt_prw), sep="");
names(GSPvalue) = paste("p.GS.", names(trt_prw), sep="");

#module = "green"
module = "cyan"
column = match(module, modNames);
moduleGenes = moduleColors==module;

sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "GS",
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, 
                   col = module)

# Output greenyellow module genes
#names(rlogtrt)[moduleColors=="greenyellow"]

GS1=as.numeric(cor(rlogtrt, trt_prw, use = "p"))
GeneSignificance=abs(GS1)
# Next module significance is defined as average gene significance.
ModuleSignificance=tapply(datME,GeneSignificance,  mean, na.rm=T)

plotModuleSignificance(
  geneTraitSignificance, 
  colors = mergedMEs, 
  #boxplot = FALSE, 
  main = "Gene significance across modules,", 
  ylab = "Gene Significance")
```

# Module membership - shorter way

```{r}
  
modColors= moduleColors

datKME <- signedKME(rlogtrt, MEs)  # equals geneModuleMembership
colnames(datKME) <- sub("kME", "MM.", colnames(datKME))
MMPval <- as.data.frame(corPvalueStudent(as.matrix(datKME), nSamples));
colnames(MMPval) <- sub("MM.", "p.MM.", colnames(MMPval))
```

# Intramodular analysis wrt diet

```{r}
# Get genes with high GS (Gene Significance) and MM (Module Membership)
  # i.e. genes with a high significance for a diet contrast
  # as well as high module membership in interesting modules

cat("\nGenerating plots for Intramodular analysis (phenotypes)\n")
colorOfColumn <- substring(names(datKME),4)

for (trait in names(trt_prw)) {
  modTraitName <- grep(paste0(trait,"$"), colnames(moduleTraitPvalue), value=T) # with prefix "p.cor" or "p.icc"
  # select 8 top associated modules for each trait given in 'trt_prw': 
  cat(paste("\ntrait:", trait, "\n"))
  selectModules <- rownames(moduleTraitPvalue[order(moduleTraitPvalue[,modTraitName], decreasing=F), , drop=F])[1:min(8, ncol(MEs))]
  selectModules <- substring(selectModules,3) # remove substring "ME"
  
  # plot 8 scatter plots for each trait
  figure.res = 300
  cex.labels <- 0.8
  
png(file.path("../../plots/IntraMod_Analysis/", 
    paste0("Intramodular_", trait, ".png")), 
    width = 210 , height = 297, units ="mm",res = figure.res)

par(mfrow=c(length(selectModules)/2,2));
par(mar=c(6, 8, 4, 4) + 0.1)

  for (module in selectModules) {
    column <- match(module,colorOfColumn)
    restModule <- modColors==module
    WGCNA::verboseScatterplot(datKME[restModule,column],geneTraitSignificance[restModule, grep(paste0(trait,"$"),names(geneTraitSignificance), value=T)],
                              xlab=paste("Module Membership:",module,"module"),ylab=paste("Gene significance:", trait),
                              main="Module membership vs. gene significance\n", 
                              cex = cex.labels, cex.axis = cex.labels, cex.lab = cex.labels, cex.main = 1.3 * cex.labels,
                              pch=21, col="black", bg=module)
  }
  dev.off()
} # end of trait-loop

```

# Output gene lists

```{r}
annot = read.csv("../../processed/DESEQ/Coexpression/FlyAnnotation.csv")
dim(annot)
names(annot)
colnames(annot)[colnames(annot)=="X"] <- "FBgn"

FBgenes = names(rlogtrt)
FBgenes2annot = match(FBgenes, annot$FBgn)
allIDs = annot$entrez[FBgenes2annot]

# The following is the number or probes without annotation:
sum(is.na(FBgenes2annot))
# Should return 0

# Get module genes
modNames
getMods <- modNames[1:22]

for (module in getMods) {
  # select module genes
  modGenes = (modColors==module)
  # Get their entrez ids
  modIDs = allIDs[modGenes]
  # Write file
  fileName = paste("../../processed/DESEQ/Coexpression/modules/entrez-", 
                   module,".txt", sep="")
  write.table(as.data.frame(modIDs), file = fileName,
              row.names = FALSE, col.names = FALSE)
}

# Save background list
fileName = paste("../../processed/DESEQ/Coexpression/modules/backList.txt",
                 sep="");
write.table(as.data.frame(allIDs), file = fileName,
           row.names = FALSE, col.names = FALSE) 
```

# GO term enrichment

```{r}
# Enrichment table containing the 10 best terms for each module
GOenr <- GOenrichmentAnalysis(modColors, allIDs, 
                              organism = "fly", nBestP = 10)
tab <- GOenr$bestPTerms[[4]]$enrichment
names(tab)
write.table(tab, file = "../../processed/DESEQ/Coexpression/modules/GOEnrichmentTable.csv", 
              sep = ",", quote = TRUE, row.names = FALSE)

# View table on screen
keepCols = c(1, 2, 5, 6, 7, 12, 13);
screenTab = tab[, keepCols];

# Round numeric columns to 2 decimal places:
numCols = c(3, 4);
screenTab[, numCols] = signif(apply(screenTab[, numCols], 2, as.numeric), 2)

# Truncate the the term name to at most 40 characters
screenTab[, 7] = substring(screenTab[, 7], 1, 40)

# Shorten the column names:
colnames(screenTab) = c("module", "size", "p-val", "Bonf", "nInTerm", "ont", "term name");
rownames(screenTab) = NULL;

# Set the width of Râ€™s output
options(width=95)

# Finally, display the enrichment table:
screenTab
write.table(screenTab, file = "../../processed/DESEQ/Coexpression/modules/GOEnrichmentTable_simple.csv", 
              sep = ",", quote = TRUE, row.names = FALSE)

```

# Visualize network eigengenes

```{r}
#  Eigengene correlation
# For one contrast as example

# Recalculate module eigengenes
MEsDRHO = moduleEigengenes(rlogtrt, modColors)$eigengenes
# Isolate weight from the clinical traits
DR_HO = as.data.frame(trt_prw$DR_H.vs.C_O);
names(DR_HO) = "DR_HO"

# Add the weight to existing module eigengenes
MET_DHRO = orderMEs(cbind(MEsDRHO, trt_prw$DR_H.vs.C_O))

# Plot the relationships among the eigengenes and the trait
sizeGrWindow(5,7.5);
par(cex = 0.9)
plotEigengeneNetworks(MET_DHRO, "", 
                      marDendro = c(0,4,1,2), 
                      marHeatmap = c(3,4,1,2), 
                      cex.lab = 0.8, 
                      xLabelsAngle = 90)

# Split dendrogram and heatmap
sizeGrWindow(6,6);
par(cex = 1.0)
plotEigengeneNetworks(MET_DHRO, "Eigengene dendrogram", marDendro = c(0,4,2,0),
plotHeatmaps = FALSE)

# Plot the heatmap matrix (note: this plot will overwrite the dendrogram plot)
par(cex = 1.0)
plotEigengeneNetworks(MET_DHRO, "Eigengene adjacency heatmap", marHeatmap = c(3,4,2,2),
plotDendrograms = FALSE, xLabelsAngle = 90)
```

# Exporting to network visualization tools: VisANT

```{r}
# The green module
# Recalculate topological overlap
TOM = TOMsimilarity(adjc, TOMType="signed")
module = "green"

# Select module probes
#probes = names(datExpr)
inModule = (modColors==module);
modGn = FBgenes[inModule];

# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modGn, modGn)

# Export the network into an edge list file VisANT can read
visGreen = exportNetworkToVisANT(modTOM,
  file = paste("../../processed/DESEQ/Coexpression/modules/VisANTInput-", 
               module, ".txt", sep=""),
  weighted = TRUE,
  threshold = 0,
  probeToGene = data.frame(annot$FBgn, annot$symbol) )
```

# Output tables

```{r}
  cat("\nGenerating Network Output Tables\n")
  networkDatOutput0 <- data.frame(featuredata, moduleColors, GS.datTraits, GSPvalue)
  
  if(!is.null(groupsets)) {
    networkDatOutput0 <- data.frame(networkDatOutput0, geneGroupsetCor, geneGroupsetPvalue, check.names = F)
  } 
  
  # sorting rows and columns if groupColumn exists
  groupColumn.name <- grep(paste0("^p.*", groupColumn),names(networkDatOutput0), value=T) # get name of pvalue-column from cor with groups
  if(length(groupColumn.name)==1) {
    # sort sequence of module-membership-columns with respect to the correlation of modules with groupColumn before adding to networkDatOutput
    # (if correlation between modules and groupColumn is already done in 'moduleTraitCor')
       modOrder = order(-abs(moduleTraitPvalue[,groupColumn.name])) 
        # Add module membership information in 'datKME' and MMPvalue in the chosen order
       networkDatOutput_MM <- data.frame(networkDatOutput0, datKME[,modOrder], MMPvalue[,modOrder], check.names = F)
       
       # Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance (if column with pvalue from cor with groupColumn exists)
       geneOrder = order(networkDatOutput0$moduleColors, -abs(networkDatOutput0[,groupColumn.name]))
       networkDatOutput0 = networkDatOutput0[geneOrder, ]
       networkDatOutput_MM  = networkDatOutput_MM[geneOrder, ]
       }
  
  write.table(networkDatOutput0,file.path(projectfolder, "networkDatOutput.txt"), row.names=F, quote=F, sep="\t")
  write.table(networkDatOutput_MM,file.path(projectfolder, "networkDatOutput_incl_MM.txt"), row.names=F, quote=F, sep="\t")

  
  
  ### saving pruned result tables: the 8 most significant modules for each trait
  for (trait in phModule) {
      # select 8 top associated modules for each trait given in 'phModule': 
      modTraitName <- grep(paste0(trait,"$"), names(moduleTraitPvalue), value=T) # with prefix "p.cor" or "p.icc"
      selectModules <- rownames(moduleTraitPvalue[order(moduleTraitPvalue[,modTraitName], decreasing=F), , drop=F])[1:min(8, ncol(MEs))]
      selectModules <- substring(selectModules,3) # remove substring "ME"
      i <- 0      
       for (module in selectModules) {
         i <- i+1
         restModule <- networkDatOutput_MM$moduleColors==module
         defColnames <- c(colnames(featuredata), "moduleColors", 
                          grep(paste0(trait,"$"), names(GS.datTraits), value=T), 
                          grep(paste0(trait,"$"), names(GSPvalue), value=T))  
         moduleColnames <- grep(paste0("MM.",module, "$"), names(networkDatOutput_MM), value=T)
         
         Output.pruned <- networkDatOutput_MM[restModule, c(defColnames, moduleColnames)]
         write.table(Output.pruned,file.path(projectfolder, "Intramodular_analysis_Traits", paste0(paste("out",trait,"no",i,"module",module, sep="_"),".txt")), 
                     row.names=F, quote=F, sep="\t")
       } # end of module-loop
  } # end of trait-loop 
```

