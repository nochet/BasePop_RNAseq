---
title: "WGCNA clustering"
author: "Enoch Ng'oma"
date: "2/5/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Tutorials
# https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-man.pdf
# https://wikis.utexas.edu/display/bioiteam/Clustering+using+WGCNA
# https://bioconductor.org/packages/release/bioc/vignettes/CVE/inst/doc/WGCNA_from_TCGA_RNAseq.html


library(WGCNA)
library(DESeq2)
library(flashClust)
library(ape)
library(limma)

options(stringsAsFactors = FALSE)
allowWGCNAThreads()
#disableWGCNAThreads()

set.seed(341072)
```

# Data

```{r}
countdata <- read.csv("../../processed/DESEQ/Expr_countData.csv")
rownames(countdata) <- countdata[,1]
countdata[,1] <- NULL
countdata <- as.matrix(countdata)

phenDat.sva <- read.csv("../../processed/DESEQ/sampleDat_with_SV.csv")
rownames(phenDat.sva) <- phenDat.sva[,1]
phenDat.sva[,1] <- NULL
phenDat.sva$batch <- as.factor(phenDat.sva$batch)
phenDat.sva$treat_tissue <- paste(phenDat.sva$treatment,"_",phenDat.sva$tissue, sep="")

load("../../processed/DESEQ/dds_deseq01.Rda")
```

# DESeq object

```{r}
dd0 <- DESeqDataSetFromMatrix(countData = countdata,
                              colData = phenDat.sva,
                              design = ~ SV1 + batch)

dd0.wg <- estimateSizeFactors(dd0)
nc <- counts(dd0.wg, normalized=TRUE)
filter <- rowSums(nc >= 10) >= 2
dd0.wg <- dd0.wg[filter,]
dd0.wg <- estimateDispersions(dd0.wg, fitType = "local")
dd0.wg <- nbinomWaldTest(dd0.wg, maxit = 1000, useOptim = TRUE)

res0 <- results(dd0.wg)
head(res0)
```

# rlog transform exprs data

```{r}
# rlog.wg0 <- rlog(dd0.wg, blind = TRUE, fitType = "parametric")
# save(rlog.wg0, file = "../../processed/DESEQ/rlog.wg0.Rda")
# write.table(assay(rlog.wg0),
#             file="../../processed/DESEQ/rlog.wg0.txt",
#             sep="\t")
```

# WGCNA Preliminaries

```{r}
rlog.wg0 <- read.table("../../processed/DESEQ/rlog.wg0.txt", 
            sep="\t", stringsAsFactors = FALSE)

# get data into WGCNA format - genes as columns, samples as rows
rlogtrt = as.data.frame(t(rlog.wg0)) 
dim(rlogtrt) 

# Check gene outliers
outls = goodSamplesGenes(rlogtrt, verbose = 3)
outls$allOK 

# Sample data to numerical format
phenDat.sva$trt_tis <- ifelse(phenDat.sva$treat_tissue == "C_B",1, 
                          ifelse(phenDat.sva$treat_tissue=="C_H",2,
                          ifelse(phenDat.sva$treat_tissue=="C_O",3,
                          ifelse(phenDat.sva$treat_tissue=="DR_B",4,
                          ifelse(phenDat.sva$treat_tissue=="DR_H",5,
                          ifelse(phenDat.sva$treat_tissue=="DR_O",6,
                          ifelse(phenDat.sva$treat_tissue=="HS_B",7,
                          ifelse(phenDat.sva$treat_tissue=="HS_H",8, 9))))))))
```

# Cluster samples to check outliers

```{r}
sampleTree = hclust(dist(rlogtrt), method = "average");

sizeGrWindow(12,9) # inches
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, 
     main = "Sample clustering to detect outliers", 
     sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)

plot(sampleTree,
main = "Sample clustering to detect outliers",
sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)

```

# Select soft power

```{r}
# Choose a soft threshold power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
sft = pickSoftThreshold(rlogtrt, powerVector=powers, 
                        verbose =5, 
                        networkType="signed")
  
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     xlab= "Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type= "n", main= paste("Scale independence"))

text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     labels=powers, cex=cex1, col="red")

abline(h=0.90, col="red")

plot(sft$fitIndices[,1], sft$fitIndices[,5], 
     xlab= "Soft Threshold (power)", 
     ylab="Mean Connectivity", 
     type="n", main = paste("Mean connectivity"))

text(sft$fitIndices[,1], sft$fitIndices[,5], 
     labels=powers, cex=cex1, col="red")
 
# Choose a power lowest power for which the scale free topology index reaches 0.90
```

# Construct a gene co-expression matrix and generate modules
# softPower threshold explained here: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

```{r}
# Build the adjacency "correlation" matrix

pe <- sft$powerEstimate

enableWGCNAThreads()
softPower = pe
adjc = adjacency(rlogtrt, 
                      power=softPower, 
                      type="signed")
#specify signed network type
head(adjc)
 
# Topological overlap matrix (TOM) of the adjacency matrix
TOM = TOMsimilarity(adjc, TOMType="signed") # specify network type

# Calculate the corresponding dissimilarity
dissTOM = 1-TOM

```

# Detect modules

```{r}
# Hierarchical clustering of the genes based on TOM dissimilarity
geneTree = flashClust(as.dist(dissTOM), method="average")
plot(geneTree, xlab="", sub="", cex=0.3, 
     main= "Gene Clustering on TOM-based dissimilarity", 
     labels= FALSE, hang=0.04)

# Set minimum number of genes in a module
minModuleSize = 20

# Module identification using dynamic tree cut algorithm
dynamicMods = cutreeDynamic(dendro= geneTree, 
                            distM= dissTOM, deepSplit=2,
                            pamRespectsDendro= FALSE, 
                            minClusterSize = minModuleSize,
                            verbose = 2)
# Modules identified
table(dynamicMods)

# Assign module colours
dynamicColors= labels2colors(dynamicMods)

table(dynamicColors)

# Plot dendrogram of igengenes
plotDendroAndColors(geneTree, dynamicColors, 'Modules', 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05, main='')

restGenes = (dynamicColors != "grey")

# Discard unassigned genes, and focus on the rest
adjc1 = adjacency(rlogtrt[,restGenes], 
                      power=softPower, 
                      type="signed")

TOM1 <- TOMsimilarity(adjc1, TOMType="signed")

dissTOM1 = 1-TOM1

# Repeat module detection
#colnames(dissTOM1) =rownames(diss1)
geneTree1 <- flashClust(as.dist(dissTOM1), method="average" )

plotDendroAndColors(geneTree1, 
                    dynamicColors[restGenes], 
                    "Dynamic Tree Cut", 
                    dendroLabels = FALSE, 
                    hang = 0.03, addGuide = TRUE, 
                    guideHang = 0.05, 
                    main = "Gene dendrogram and module colors")

# Set the diagonal of the dissimilarity to NA 
diag(dissTOM1) = NA;

# Visualize the Tom plot. 
# Raise the dissimilarity matrix to the power of 4 to bring out the module structure
sizeGrWindow(4,4)

TOMplot(dissTOM1, geneTree1, 
        as.character(dynamicColors[restGenes]))

# Extract modules

module_colors= setdiff(unique(dynamicColors), "grey")
for (color in module_colors){
    module=rlogtrt[which(dynamicColors==color)]
    write.table(module, paste("module_",color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}
```

# Merge modules whose expression profiles are very similar

```{r}
# Calculate eigengenes
MEList= moduleEigengenes(rlogtrt, 
                         colors= dynamicColors,
                         softPower = softPower)
                         
MEs= MEList$eigengenes;

# Calculate dissimilarity of module eigengenes
MEDiss= 1-cor(MEs);

# Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")

# Plot the module tree with phytools package
par(mar=c(2,2,2,2))

plot.phylo(as.phylo(METree),type = 'fan',
           show.tip.label = FALSE, main='')
tiplabels(frame = 'circle',col='black',
          text=rep('',length(unique(dynamicMods))), 
          bg = levels(as.factor(dynamicColors)))

# Plot with WGCNA
sizeGrWindow(7,6)
plot(METree, main = "clustering of module eigengene",
     xlab = "", sub = "")

save(dynamicMods, MEList, MEs, MEDiss, METree, file= "../../processed/DESEQ/Network_allSamples_signed_RLDfiltered.RData")
```

# Merge at a selected threshold

```{r}
# Set threshold for merging modules 
# Can choose no merge i.e. MEDissThres=0.0)
# A height cut of 0.25, corresponds to correlation of 0.75
MEDissThres = 0.25
abline(h=MEDissThres, col ="red")

# Call automatic merging function
merge = mergeCloseModules(rlogtrt, 
                          dynamicColors, 
                          cutHeight= MEDissThres, 
                          verbose =3)
mergedColors = merge$colors;
mergedMEs = merge$newMEs;
#dev.off()

# Plot dendrogram with module colors below it
#pdf(file="../../plots/cluster.pdf")
plotDendroAndColors(geneTree, 
                    cbind(dynamicColors, mergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels= FALSE, hang=0.03, 
                    addGuide= TRUE, guideHang=0.05)
#dev.off()

# Rename to moduleColors
moduleColors = mergedColors

# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;

save(MEs, moduleLabels, moduleColors, geneTree, 
     file= "../../processed/DESEQ/Network_allSamples_signed_merge.RData")

```

# Visualize weighted network via heatmap

```{r}
# Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^20;

# Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;

# Call the plot function
pdf(file = "../../plots/weighted_heat.pdf", wi = 6, he = 6)

sizeGrWindow(6,6)
TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, all genes")

dev.off()

# For 400 genes
nSelect = 400
# For reproducibility, we set the random seed
set.seed(10);
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

select = sample(nGenes, size = nSelect);
selectTOM = dissTOM[select, select];

# There’s no simple way to restrict tree to a subset of genes, so must re-cluster
selectTree = hclust(as.dist(selectTOM), method = "average")
selectColors = moduleColors[select];

pdf(file = "../../plots/weighted_heat.pdf", wi = 7, he = 7)
sizeGrWindow(7,7)
# Taking the dissimilarity to a power, say 10, makes the plot more informative by effectively changing
# the color palette; setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^20;
diag(plotDiss) = NA;
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap, 400 genes")
dev.off()
```

# Relate gene expression modules to sample traits
# https://peterlangfelder.com/2018/11/25/working-with-categorical-variables/

```{r}
# Sample info
phenDat1 <- phenDat.sva[,c(6,7)]

# Binarize categorical variable into pairwise indicators
phen.bin1 = binarizeCategoricalVariable(phenDat1$trt,
includePairwise = TRUE,
includeLevelVsAll = FALSE,
dropUninformative = TRUE,
includeLevelInformation = TRUE);
# Print the variable and the indicators
data.frame(phenDat1,phen.bin1);

# rlog-transformed exprs data
rlogtrt <- read.table("../../processed/DESEQ/rlog.wg0.txt", 
                       sep = "\t",
                       stringsAsFactors = FALSE)

# Check and order sample IDs to match exprs ids
# all(rownames(phen.bin) %in% colnames(rlogtrt))
# rlogtrt <- rlogtrt[, rownames(phen.bin)]
# all(rownames(phen.bin) == colnames(rlogtrt))

rlogtrt = as.data.frame(t(rlogtrt)) 
dim(rlogtrt) 

# Correlate traits 
# Define number of genes and samples
nGenes = ncol(rlogtrt)
nSamples = nrow(rlogtrt)

# Recalculate module eigengens
MEs = moduleEigengenes(rlogtrt, moduleColors)$eigengenes

# Isolate treatment from sample data
trt <- as.data.frame(phenDat.sva$trt);
names(trt) = "treatment"

# Add the weight to existing module eigengenes
MET = orderMEs(cbind(MEs, trt))

# Plot the relationships among the eigengenes and the trait
sizeGrWindow(9,9);
par(cex = 0.9)
plotEigengeneNetworks(MET, "", marDendro = c(0,4,1,2), 
                      marHeatmap = c(3,4,1,2), 
                      cex.lab = 0.8, 
                      xLabelsAngle = 90)

# Can split dendrogram from heatmap
sizeGrWindow(6,6);
par(cex = 1.0)
plotEigengeneNetworks(MET, "Eigengene dendrogram", marDendro = c(0,4,2,0),
                    plotHeatmaps = FALSE)

par(cex = 1.0)
plotEigengeneNetworks(MET, "Eigengene adjacency heatmap", marHeatmap = c(3,4,2,2),
                    plotDendrograms = FALSE, xLabelsAngle = 90)


```

